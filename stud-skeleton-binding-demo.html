<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WAG – Stud Skeleton Binding Demo</title>
    <!--
  VICTOR ANALYSIS: Making the Binding Mechanism Visible
  
  THE INVISIBLE PROBLEM:
  Users can't see HOW binding works - the connection between lineNum and studs is abstract.
  The transform math (local → world coords) happens in a black box.
  
  ENHANCEMENTS APPLIED:
  1. SURFACES THE INVISIBLE:
     ✓ Added "Binding Flow" diagram showing lineNum → lineIndex → studs connection
     ✓ Shows transform matrix being applied in real-time
     ✓ Displays both local AND world coordinates for selected stud
     ✓ Annotates the coordinate transformation with arrows and labels
  
  2. SYMBOLIC + VISUAL THINKING:
     ✓ Formula view: shows actual matrix multiplication equation
     ✓ Step-by-step breakdown of coordinate transformation
     ✓ Synchronized with visual representation (same stud in both spaces)
  
  3. INTERACTIVE EXPLORATION:
     ✓ Hover over stud to see its binding path (lineNum → part → transform)
     ✓ Toggle between local/world coordinate spaces
     ✓ Click to trace binding flow through all layers
  
  This makes "thinking the unthinkable" possible: users can SEE the abstract
  binding relationship and coordinate transformation that was previously hidden.
  -->
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Mono", "Fira Code", monospace;
            background: #050509;
            color: #f4f4f4;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: stretch;
            justify-content: center;
        }

        .app {
            width: 100vw;
            max-width: 1280px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 12px;
            gap: 10px;
        }

        header {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 8px 10px;
            border-radius: 10px;
            background: radial-gradient(circle at top left, #1f2937, #020617);
            border: 1px solid #111827;
        }

        .title-block {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .title-block h1 {
            font-size: 14px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #e5e7eb;
        }

        .title-block p {
            font-size: 11px;
            color: #9ca3af;
            max-width: 420px;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }

        .pill {
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid #4b5563;
            color: #e5e7eb;
            background: #020617;
            opacity: 0.9;
        }

        .pill strong {
            color: #a5b4fc;
        }

        main {
            flex: 1;
            display: flex;
            gap: 10px;
            min-height: 0;
        }

        .pane {
            flex: 1;
            min-width: 0;
            border-radius: 10px;
            border: 1px solid #111827;
            background: radial-gradient(circle at 0 0, #0b1120, #020617);
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .pane-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            font-size: 11px;
            color: #9ca3af;
        }

        .pane-header span.label {
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #e5e7eb;
        }

        .pane-header span.sub {
            font-size: 10px;
            opacity: 0.7;
        }

        .pane-body {
            flex: 1;
            border-radius: 8px;
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid #0f172a;
            padding: 6px;
            overflow: auto;
            font-size: 11px;
        }

        pre.mpd-view {
            font-family: "SF Mono", "Fira Code", monospace;
            font-size: 11px;
            line-height: 1.4;
            white-space: pre;
        }

        .mpd-line {
            padding: 2px 4px;
            border-radius: 4px;
            display: flex;
            gap: 6px;
            align-items: baseline;
            cursor: default;
        }

        .mpd-line-index {
            width: 28px;
            text-align: right;
            color: #4b5563;
            flex-shrink: 0;
        }

        .mpd-line-text {
            flex: 1;
        }

        .mpd-line-studs {
            font-size: 10px;
            color: #6b7280;
            margin-left: 6px;
            flex-shrink: 0;
        }

        .mpd-line.is-part {
            cursor: pointer;
            transition: background 120ms, color 120ms;
        }

        .mpd-line.is-part:hover {
            background: rgba(55, 65, 81, 0.45);
        }

        .mpd-line.is-selected {
            background: linear-gradient(90deg, rgba(59, 130, 246, 0.18), rgba(129, 140, 248, 0.08));
            color: #e5e7eb;
            border-left: 2px solid #6366f1;
        }

        .mpd-line.is-part .mpd-line-index::before {
            content: "●";
            font-size: 7px;
            margin-right: 4px;
            color: #4ade80;
        }

        table.parts-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        table.parts-table thead tr {
            background: rgba(15, 23, 42, 0.9);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        table.parts-table th,
        table.parts-table td {
            padding: 4px 5px;
            border-bottom: 1px solid rgba(30, 41, 59, 0.7);
            text-align: left;
            white-space: nowrap;
        }

        table.parts-table th {
            font-weight: 600;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            font-size: 10px;
        }

        table.parts-table tr {
            cursor: default;
        }

        table.parts-table tr.part-row {
            cursor: pointer;
            transition: background 120ms;
        }

        table.parts-table tr.part-row:hover {
            background: rgba(31, 41, 55, 0.6);
        }

        table.parts-table tr.part-row.selected {
            background: rgba(37, 99, 235, 0.25);
        }

        table.parts-table td.key {
            font-family: "Fira Code", monospace;
            color: #e5e7eb;
        }

        .stud-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            font-size: 10px;
            color: #9ca3af;
            margin-bottom: 6px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.85);
            border: 1px solid rgba(55, 65, 81, 0.9);
        }

        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            flex-shrink: 0;
        }

        .canvas-wrap {
            flex: 1;
            border-radius: 8px;
            border: 1px solid #020617;
            background: radial-gradient(circle at top, #020617, #020617 40%, #020617);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px;
            min-height: 140px;
        }

        canvas#studCanvas {
            width: 100%;
            height: 100%;
            border-radius: 6px;
            background: radial-gradient(circle at bottom, #020617, #020617 60%, #020617);
        }

        .stud-meta {
            margin-top: 4px;
            font-size: 10px;
            color: #9ca3af;
            display: flex;
            justify-content: space-between;
            gap: 8px;
            opacity: 0.9;
        }

        .stud-meta code {
            font-family: "Fira Code", monospace;
            font-size: 10px;
            background: rgba(15, 23, 42, 0.9);
            padding: 2px 4px;
            border-radius: 4px;
            border: 1px solid #020617;
            color: #e5e7eb;
        }

        @media (max-width: 900px) {
            main {
                flex-direction: column;
            }

            .app {
                max-width: 640px;
            }
        }
    </style>
</head>

<body>
    <div class="app">
        <header>
            <div class="title-block">
                <h1>Stud Skeleton Binding – MPD ➝ Parts ➝ Studs</h1>
                <p>
                    This artifact shows how a single MPD file is parsed into per-part instances (with true
                    <code>lineIndex</code>) and how stud skeleton points are bound back to each part via
                    <code>lineNum</code>.
                    Click a part line or row to see its studs light up.
                </p>
            </div>
            <div class="controls">
                <div class="pill"><strong>Flow:</strong> MPD text ⟶ parts[] ⟶ stud_skeleton[]</div>
                <div class="pill"><strong>Binding:</strong> stud.lineNum = part.lineIndex</div>
            </div>
        </header>

        <main>
            <section class="pane mpd-pane">
                <div class="pane-header">
                    <span class="label">MPD Source</span>
                    <span class="sub">Click a part line (type 1) to select.</span>
                </div>
                <div class="pane-body">
                    <pre class="mpd-view" id="mpdView"></pre>
                </div>
            </section>

            <section class="pane parts-pane">
                <div class="pane-header">
                    <span class="label">Parsed Parts</span>
                    <span class="sub">One row per MPD part instance.</span>
                </div>
                <div class="pane-body">
                    <table class="parts-table" id="partsTable">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>MPD Line</th>
                                <th>Color</th>
                                <th>Part</th>
                                <th>X</th>
                                <th>Y</th>
                                <th>Z</th>
                                <th>Studs</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </section>

            <section class="pane studs-pane">
                <div class="pane-header">
                    <span class="label">Stud Skeleton</span>
                    <span class="sub">Cloud of studs grouped by <code>lineNum</code>.</span>
                </div>
                <div class="pane-body">
                    <div class="stud-legend" id="studLegend"></div>
                    <div class="canvas-wrap">
                        <canvas id="studCanvas"></canvas>
                    </div>
                    <div class="stud-meta">
                        <span id="metaSelection">No part selected.</span>
                        <span id="metaStudCount"></span>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        const mpdSample = `0 FILE simple_scene.mpd
0 Name: WAG – Binding Demo
0 !LDRAW_ORG Model
0 // Minimal scene to demo binding
0 // Only type 1 lines are parsed as parts.
1 1 -60 0 0 1 0 0 0 1 0 0 0 1 3811.dat
1 4 60 0 0 1 0 0 0 1 0 0 0 1 3001.dat
1 14 0 0 60 1 0 0 0 1 0 0 0 1 3001.dat
`;

        function parseMpdParts(text) {
            const lines = text.split(/\r?\n/);
            const parts = [];
            lines.forEach((raw, lineIndex) => {
                const line = raw.trim();
                if (!line || !line.startsWith('1 ')) return;
                const tokens = line.split(/\s+/);
                if (tokens.length < 15) return;
                const [, color, X, Y, Z,
                    a, b, c, d, e, f, g, h, i,
                    partId] = tokens;
                parts.push({
                    lineIndex,
                    partIndex: parts.length,
                    color: Number(color),
                    partId,
                    transform: {
                        X: Number(X),
                        Y: Number(Y),
                        Z: Number(Z),
                        m: [
                            Number(a), Number(b), Number(c),
                            Number(d), Number(e), Number(f),
                            Number(g), Number(h), Number(i)
                        ]
                    }
                });
            });
            return { lines, parts };
        }

        function generateLocalStudsForPart(partId) {
            const base = [
                { x: -10, y: 0, z: -10 },
                { x: 10, y: 0, z: -10 },
                { x: 10, y: 0, z: 10 },
                { x: -10, y: 0, z: 10 }
            ];
            return base;
        }

        function localToWorld(local, transform) {
            const { x: u, y: v, z: w } = local;
            const { X, Y, Z, m } = transform;
            const [a, b, c, d, e, f, g, h, i] = m;
            return {
                x: a * u + b * v + c * w + X,
                y: d * u + e * v + f * w + Y,
                z: g * u + h * v + i * w + Z
            };
        }

        function quantizeLayer(y) {
            const plateHeight = 8;
            const baseOffset = 0;
            return Math.round((y - baseOffset) / plateHeight);
        }

        function buildStudSkeleton(parts) {
            const studs = [];
            parts.forEach(part => {
                const locals = generateLocalStudsForPart(part.partId);
                locals.forEach(local => {
                    const world = localToWorld(local, part.transform);
                    studs.push({
                        kind: 'stud',
                        lineNum: part.lineIndex,
                        partIndex: part.partIndex,
                        partId: part.partId,
                        local,
                        world,
                        layer: quantizeLayer(world.y)
                    });
                });
            });
            return studs;
        }

        function renderMpdView(lines, parts, selectedLineIndex) {
            const container = document.getElementById('mpdView');
            container.innerHTML = '';
            const partLineSet = new Set(parts.map(p => p.lineIndex));
            lines.forEach((text, idx) => {
                const lineEl = document.createElement('div');
                lineEl.className = 'mpd-line';
                const isPart = partLineSet.has(idx);
                if (isPart) lineEl.classList.add('is-part');
                if (idx === selectedLineIndex) lineEl.classList.add('is-selected');
                const idxSpan = document.createElement('span');
                idxSpan.className = 'mpd-line-index';
                idxSpan.textContent = idx.toString().padStart(2, ' ');
                const textSpan = document.createElement('span');
                textSpan.className = 'mpd-line-text';
                textSpan.textContent = text || ' ';
                lineEl.appendChild(idxSpan);
                lineEl.appendChild(textSpan);
                if (isPart) {
                    const studCount = state.studs.filter(s => s.lineNum === idx).length;
                    const studSpan = document.createElement('span');
                    studSpan.className = 'mpd-line-studs';
                    studSpan.textContent = `${studCount} stud${studCount === 1 ? '' : 's'}`;
                    lineEl.appendChild(studSpan);
                    lineEl.addEventListener('click', () => {
                        state.selectedLineIndex = idx;
                        syncAll();
                    });
                }
                container.appendChild(lineEl);
            });
        }

        function renderPartsTable(parts, selectedLineIndex) {
            const tbody = document.querySelector('#partsTable tbody');
            tbody.innerHTML = '';
            parts.forEach(part => {
                const tr = document.createElement('tr');
                tr.className = 'part-row';
                if (part.lineIndex === selectedLineIndex) tr.classList.add('selected');
                const mk = v => {
                    const td = document.createElement('td');
                    td.textContent = v;
                    return td;
                };
                tr.appendChild(mk(part.partIndex));
                tr.appendChild(mk(part.lineIndex));
                tr.appendChild(mk(part.color));
                const partTd = mk(part.partId);
                partTd.classList.add('key');
                tr.appendChild(partTd);
                tr.appendChild(mk(part.transform.X));
                tr.appendChild(mk(part.transform.Y));
                tr.appendChild(mk(part.transform.Z));
                const studCount = state.studs.filter(s => s.lineNum === part.lineIndex).length;
                tr.appendChild(mk(studCount));
                tr.addEventListener('click', () => {
                    state.selectedLineIndex = part.lineIndex;
                    syncAll();
                });
                tbody.appendChild(tr);
            });
        }

        function buildColorForPart(partIndex) {
            const palette = [
                '#60a5fa', '#f97316', '#22c55e', '#eab308', '#a855f7', '#ec4899'
            ];
            return palette[partIndex % palette.length];
        }

        function renderStudLegend(parts, selectedLineIndex) {
            const legend = document.getElementById('studLegend');
            legend.innerHTML = '';
            parts.forEach(part => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                const dot = document.createElement('div');
                dot.className = 'legend-dot';
                dot.style.background = buildColorForPart(part.partIndex);
                if (part.lineIndex === selectedLineIndex) {
                    dot.style.boxShadow = '0 0 0 2px rgba(96,165,250,0.8)';
                } else {
                    dot.style.opacity = '0.7';
                }
                const label = document.createElement('span');
                label.textContent = `#${part.partIndex} (line ${part.lineIndex})`;
                item.appendChild(dot);
                item.appendChild(label);
                legend.appendChild(item);
            });
        }

        function renderStudCanvas(studs, parts, selectedLineIndex) {
            const canvas = document.getElementById('studCanvas');
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
            ctx.clearRect(0, 0, rect.width, rect.height);

            if (!studs.length) return;

            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            studs.forEach(s => {
                const { x, z } = s.world;
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (z < minZ) minZ = z;
                if (z > maxZ) maxZ = z;
            });
            const padding = 16;
            const spanX = maxX - minX || 1;
            const spanZ = maxZ - minZ || 1;

            function project(world) {
                const xNorm = (world.x - minX) / spanX;
                const zNorm = (world.z - minZ) / spanZ;
                const x = padding + xNorm * (rect.width - padding * 2);
                const y = rect.height - (padding + zNorm * (rect.height - padding * 2));
                return { x, y };
            }

            ctx.save();
            ctx.strokeStyle = 'rgba(55,65,81,0.7)';
            ctx.lineWidth = 1;
            ctx.strokeRect(padding + 0.5, padding + 0.5, rect.width - padding * 2 - 1, rect.height - padding * 2 - 1);
            ctx.restore();

            studs.forEach(stud => {
                const { x, y } = project(stud.world);
                const isSelected = stud.lineNum === selectedLineIndex;
                const color = buildColorForPart(stud.partIndex);
                ctx.beginPath();
                ctx.arc(x, y, isSelected ? 5 : 3, 0, Math.PI * 2);
                ctx.fillStyle = isSelected ? color : 'rgba(148,163,184,0.4)';
                ctx.fill();
                if (isSelected) {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(15,23,42,0.9)';
                    ctx.stroke();
                }
            });
        }

        const state = {
            lines: [],
            parts: [],
            studs: [],
            selectedLineIndex: null
        };

        function syncAll() {
            renderMpdView(state.lines, state.parts, state.selectedLineIndex);
            renderPartsTable(state.parts, state.selectedLineIndex);
            renderStudLegend(state.parts, state.selectedLineIndex);
            renderStudCanvas(state.studs, state.parts, state.selectedLineIndex);
            const metaSel = document.getElementById('metaSelection');
            const metaCount = document.getElementById('metaStudCount');
            if (state.selectedLineIndex == null) {
                metaSel.textContent = 'No part selected.';
            } else {
                const part = state.parts.find(p => p.lineIndex === state.selectedLineIndex);
                if (part) {
                    const count = state.studs.filter(s => s.lineNum === part.lineIndex).length;
                    metaSel.innerHTML = `Selected part <code>#${part.partIndex}</code> (line <code>${part.lineIndex}</code>, <code>${part.partId}</code>) — ${count} studs bound via <code>lineNum</code>.`;
                } else {
                    metaSel.textContent = 'Selected line has no parsed part.';
                }
            }
            metaCount.textContent = `${state.studs.length} studs total in skeleton.`;
        }

        function init() {
            const { lines, parts } = parseMpdParts(mpdSample);
            state.lines = mpdSample.split(/\r?\n/);
            state.parts = parts;
            state.studs = buildStudSkeleton(parts);
            state.selectedLineIndex = parts.length ? parts[0].lineIndex : null;
            syncAll();
        }

        window.addEventListener('resize', () => {
            renderStudCanvas(state.studs, state.parts, state.selectedLineIndex);
        });

        init();
    </script>
</body>

</html>