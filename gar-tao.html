<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>ONYX Storytelling System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Playfair+Display:wght@400;500;600;700&display=swap"
        rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <script>
        // Tailwind config for 20x20 grid
        tailwind.config = {
            theme: {
                extend: {
                    gridTemplateColumns: {
                        '20': 'repeat(20, minmax(0, 1fr))'
                    },
                    gridTemplateRows: {
                        '20': 'repeat(20, minmax(0, 1fr))'
                    }
                }
            }
        }
    </script>
    <style>
        :root {
            --theme-bg: #0b1121;
            --theme-panel: #0f172a;
            --theme-surface: #1e293b;
            --theme-border: #334155;
            --theme-text-main: #e2e8f0;
            --theme-text-muted: #64748b;
            --theme-entity: #60a5fa;
            --theme-core: #fbbf24;
            --theme-goal: #4ade80;
            --theme-obstacle: #f87171;
            --theme-morphism: #22d3ee;
            --theme-scene: #c084fc;
            --theme-story: #e879f9;
            --ease: cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--theme-bg);
            color: var(--theme-text-main);
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent;
        }

        body.sidebar-collapsed {
            grid-template-columns: 0px 1fr 320px;
        }

        body.inspector-collapsed {
            grid-template-columns: 288px 1fr 0px;
        }

        body.sidebar-collapsed.inspector-collapsed {
            grid-template-columns: 0px 1fr 0px;
        }

        body.console-collapsed {
            grid-template-rows: 64px 1fr 0px;
        }

        body.sidebar-collapsed aside[data-panel="sidebar"],
        body.inspector-collapsed aside[data-panel="inspector"],
        body.console-collapsed [data-panel="console"] {
            display: none;
        }

        .theme-dark {
            --theme-bg: #0b1121;
            --theme-panel: #0f172a;
            --theme-surface: #1e293b;
            --theme-border: #334155;
            --theme-text-main: #e2e8f0;
            --theme-text-muted: #64748b;
        }

        .theme-parchment {
            --theme-bg: #fefce8;
            --theme-panel: #fef9c3;
            --theme-surface: #fde047;
            --theme-border: #facc15;
            --theme-text-main: #713f12;
            --theme-text-muted: #ca8a04;
        }

        .theme-terminal {
            --theme-bg: #0a0a0a;
            --theme-panel: #171717;
            --theme-surface: #262626;
            --theme-border: #404040;
            --theme-text-main: #86efac;
            --theme-text-muted: #525252;
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes grid-fade {
            0% {
                opacity: 0.05;
            }

            100% {
                opacity: 0.15;
            }
        }

        .animate-slide-in-right {
            animation: slideInRight 0.3s var(--ease) forwards;
        }

        .animate-fade-up {
            animation: fadeUp 0.3s var(--ease) forwards;
        }

        .animate-grid-fade {
            animation: grid-fade 2s ease-in-out infinite alternate;
        }

        .grid-overlay {
            background-image: linear-gradient(var(--theme-border) 1px, transparent 1px),
                linear-gradient(90deg, var(--theme-border) 1px, transparent 1px);
            background-size: 11.11% 11.11%;
        }

        .node-instance {
            position: absolute;
            transform: translate(-50%, -50%);
            cursor: grab;
            z-index: 20;
            transition: all 0.2s var(--ease);
        }

        .node-instance:active {
            cursor: grabbing;
        }

        .node-instance.selected {
            filter: drop-shadow(0 0 20px var(--theme-core));
        }

        .node-halo {
            position: absolute;
            inset: -10px;
            border-radius: 50%;
            background: radial-gradient(circle, var(--theme-core) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s var(--ease);
            pointer-events: none;
        }

        .node-instance:hover .node-halo {
            opacity: 0.3;
        }

        .node-instance.selected .node-halo {
            opacity: 0.6;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.6;
            }

            50% {
                transform: scale(1.1);
                opacity: 0.3;
            }
        }

        .tool-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border: 1px solid var(--theme-border);
            border-radius: 0.5rem;
            background: var(--theme-surface);
            cursor: pointer;
            transition: all 0.2s var(--ease);
        }

        .tool-item:hover {
            background: var(--theme-panel);
            border-color: var(--theme-core);
            transform: translateX(4px);
        }

        .nav-tab {
            transition: all 0.2s var(--ease);
        }

        .nav-tab.active {
            background: var(--theme-core);
            color: var(--theme-bg);
        }

        .theme-btn.active {
            background: var(--theme-core);
            color: var(--theme-bg);
        }

        .toast {
            background: var(--theme-surface);
            border: 1px solid var(--theme-border);
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s var(--ease);
        }

        .grid-cell {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s var(--ease);
        }

        .grid-cell:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .grid-cell.focus {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.3);
        }

        .grid-cell.neighbor {
            background: rgba(96, 165, 250, 0.06);
            border-color: rgba(96, 165, 250, 0.35);
        }

        .log-entry {
            font-size: 0.75rem;
            padding: 0.5rem;
            border-bottom: 1px solid var(--theme-border);
            font-family: 'JetBrains Mono', monospace;
        }

        .log-success {
            color: #22c55e;
        }

        .log-info {
            color: #60a5fa;
        }

        .log-warn {
            color: #fbbf24;
        }

        .log-error {
            color: #f87171;
        }
    </style>
</head>

<body class="theme-dark grid grid-cols-[288px_1fr_320px] grid-rows-[64px_1fr_200px] h-screen w-screen overflow-hidden">

    <!-- Toast Notifications -->
    <div id="toast-container" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 z-50 flex flex-col gap-2 w-80">
    </div>

    <!-- Header -->
    <header
        class="col-span-3 bg-[var(--theme-panel)] border-b border-[var(--theme-border)] flex items-center justify-between px-4">
        <div class="flex gap-2 bg-[var(--theme-surface)] p-1 rounded-lg">
            <button class="nav-tab active px-3 py-2 rounded-md text-sm font-medium transition-all"
                data-view="system">SYSTEM</button>
            <button
                class="nav-tab px-3 py-2 rounded-md text-sm font-medium text-[var(--theme-text-muted)] transition-all"
                data-view="story">STORY</button>
            <button
                class="nav-tab px-3 py-2 rounded-md text-sm font-medium text-[var(--theme-text-muted)] transition-all"
                data-view="preview">PREVIEW</button>
        </div>
        <div class="flex items-center gap-4">
            <div class="flex items-center gap-2 text-[10px] text-[var(--theme-text-muted)]">
                <span class="uppercase tracking-wide">Scene</span>
                <select id="scene-picker"
                    class="bg-[var(--theme-bg)] border border-[var(--theme-border)] rounded px-2 py-1 text-[10px] text-[var(--theme-text-main)] min-w-[140px]"></select>
                <button id="scene-export"
                    class="px-2 py-1 border border-[var(--theme-border)] rounded text-[10px] text-[var(--theme-text-muted)] hover:border-[var(--theme-core)]">
                    Sync
                </button>
            </div>
            <div class="flex gap-1 p-1 bg-[var(--theme-surface)] rounded-md">
                <button class="theme-btn active px-2 py-1 rounded text-xs font-medium" data-theme="dark">DARK</button>
                <button class="theme-btn px-2 py-1 rounded text-xs font-medium text-[var(--theme-text-muted)]"
                    data-theme="parchment">PARCH</button>
                <button class="theme-btn px-2 py-1 rounded text-xs font-medium text-[var(--theme-text-muted)]"
                    data-theme="terminal">TERM</button>
            </div>
        </div>
    </header>

    <!-- Sidebar -->
    <aside data-panel="sidebar"
        class="bg-[var(--theme-panel)] border-r border-[var(--theme-border)] flex flex-col transition-all duration-300 overflow-y-auto">
        <div class="h-16 border-b border-[var(--theme-border)] flex items-center justify-between px-4">
            <div class="flex flex-col">
                <span class="font-bold text-lg text-[var(--theme-text-main)]">ONYX</span>
                <span class="text-[10px] text-[var(--theme-core)] uppercase tracking-wider">Storytelling System</span>
            </div>
            <button id="sidebar-toggle" onclick="LAYOUT.toggleSidebar()"
                class="text-[var(--theme-text-muted)] hover:text-[var(--theme-text-main)] text-xs border border-[var(--theme-border)] rounded px-1 py-0.5">
                <i class="fas fa-chevron-left w-3 h-3"></i>
            </button>
        </div>

        <div class="p-4 border-b border-[var(--theme-border)]">
            <div class="text-xs text-[var(--theme-text-muted)] uppercase tracking-wide mb-2">Natural Language</div>
            <input id="narrative-input" type="text"
                class="w-full bg-[var(--theme-bg)] border border-[var(--theme-border)] rounded-md p-2 text-xs text-[var(--theme-text-main)] font-mono"
                placeholder="Alice wants Wonderland">
            <div class="mt-2 flex gap-2">
                <button onclick="COMPILER.commit()"
                    class="flex-1 px-2 py-1 bg-[var(--theme-surface)] border border-[var(--theme-border)] rounded text-xs hover:border-[var(--theme-core)]">
                    <i class="fas fa-play w-3 h-3 mr-1"></i>Compile
                </button>
            </div>
        </div>

        <div class="p-2">
            <div class="text-xs text-[var(--theme-text-muted)] uppercase tracking-wide mb-2 px-2">Entity Palette</div>
            <div id="tools-list" class="flex flex-col gap-2"></div>
        </div>

        <div class="mt-auto p-4 border-t border-[var(--theme-border)]">
            <div class="text-xs text-[var(--theme-text-muted)] uppercase tracking-wide mb-2">Scenarios</div>
            <button onclick="COMPILER.loadScenario('heist')" class="tool-item w-full justify-center mb-2">
                <i class="fas fa-gem w-4 h-4"></i>
                <span>Heist</span>
            </button>
            <button onclick="COMPILER.loadScenario('romance')" class="tool-item w-full justify-center">
                <i class="fas fa-heart w-4 h-4"></i>
                <span>Romance</span>
            </button>
        </div>
    </aside>

    <!-- Canvas -->
    <main class="relative bg-[var(--theme-bg)] overflow-hidden">
        <div id="grid-shell" class="absolute inset-0">
            <div class="absolute inset-0 animate-grid-fade opacity-10 pointer-events-none grid-overlay"></div>
            <div id="grid-lock" class="absolute inset-0 grid grid-cols-20 grid-rows-20 gap-0 p-0"></div>
            <div id="nodes-layer" class="absolute inset-0 z-10 pointer-events-none"></div>
            <svg id="connections-layer" viewBox="0 0 100 100" preserveAspectRatio="none"
                style="position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;">
            </svg>
            <div id="preview-content" class="absolute inset-0 hidden p-8 overflow-y-auto"></div>
            <div class="absolute bottom-4 left-4 text-[10px] text-cyan-500/60 font-mono">
                NODES: <span id="node-count">0</span> | LINKS: <span id="link-count">0</span>
            </div>
        </div>
        <div id="scene-fork-indicator"
            class="absolute top-3 right-4 px-2 py-1 rounded border border-[var(--theme-core)] bg-[var(--theme-surface)] text-[10px] uppercase tracking-wide text-[var(--theme-core)] shadow-lg hidden animate-pulse">
        </div>
    </main>

    <!-- Inspector -->
    <aside data-panel="inspector"
        class="bg-[var(--theme-panel)] border-l border-[var(--theme-border)] flex flex-col transition-all duration-300 overflow-y-auto">
        <div class="h-12 border-b border-[var(--theme-border)] flex items-center justify-between px-4">
            <div class="flex items-center gap-2">
                <div class="w-2 h-2 bg-cyan-400 rounded-full animate-pulse"></div>
                <span class="font-bold text-sm text-[var(--theme-text-main)]">Inspector</span>
            </div>
            <div class="flex items-center gap-1">
                <button onclick="LAYOUT.toggleInspector()"
                    class="text-[var(--theme-text-muted)] hover:text-white text-xs border border-[var(--theme-border)] rounded px-1 py-0.5">
                    <i class="fas fa-chevron-right w-3 h-3"></i>
                </button>
                <button onclick="INSPECTOR.close()" class="text-[var(--theme-text-muted)] hover:text-white">
                    <i class="fas fa-times w-4 h-4"></i>
                </button>
                <button id="btn-reset" title="Reset Grid"
                    style="background: #dc2626; border-color: #dc2626;">üóëÔ∏è</button>
                <div class="w-px h-4 bg-[var(--theme-border)] mx-2"></div>
                <button id="btn-export-frank" title="Export as Frank JSON">üìÑ</button>
                <button id="btn-export-mpd" title="Export as LDraw MPD">üß±</button>
            </div>
        </div>
        <div id="inspector-content" class="flex-1 p-4">
            <div class="text-sm text-[var(--theme-text-muted)] text-center py-8">
                Select a node to inspect
            </div>
        </div>
        <div class="p-4 border-t border-[var(--theme-border)]">
            <button onclick="INSPECTOR.delete()"
                class="w-full py-3 bg-red-500/20 text-red-500 border border-red-500 rounded-md text-xs font-bold uppercase">
                DELETE ENTITY
            </button>
        </div>
    </aside>

    <!-- Console -->
    <div data-panel="console"
        class="col-span-3 bg-[var(--theme-panel)] border-t border-[var(--theme-border)] transition-all duration-300">
        <div id="console-header"
            class="h-8 bg-[var(--theme-surface)] flex items-center justify-between px-4 cursor-pointer"
            onclick="CONSOLE.toggle()">
            <div class="flex items-center gap-2 text-xs text-[var(--theme-text-muted)] font-bold">
                <i class="fas fa-terminal w-3 h-3"></i>
                <span>SYSTEM CONSOLE</span>
            </div>
            <i id="console-toggle-icon" class="fas fa-chevron-down w-3 h-3 text-slate-400"></i>
        </div>
        <div id="console-content" class="h-[calc(100%-2rem)] overflow-y-auto p-2"></div>
    </div>

    <script>
        // =========================================
        // STATE MANAGEMENT
        // =========================================
        const STATE = {
            nodes: [],
            links: [],
            selectedNodeId: null,
            viewMode: 'system',
            theme: 'dark',
            draggedNodeId: null,
            lastX: 0,
            lastY: 0,
            sceneMeta: null,
            sidebarCollapsed: false,
            inspectorCollapsed: false,
            consoleCollapsed: false
        };

        // =========================================
        // GRID HELPERS
        // =========================================
        const GRID = {
            center(col, row) {
                const step = 100 / 9;
                const x = (col + 0.5) * step;
                const y = (row + 0.5) * step;
                return { x, y, row, col, cellIndex: row * 9 + col };
            },
            snap(x, y) {
                const step = 100 / 9;
                const col = Math.max(0, Math.min(8, Math.round(x / step - 0.5)));
                const row = Math.max(0, Math.min(8, Math.round(y / step - 0.5)));
                return this.center(col, row);
            },

            highlightNeighborhood(node) {
                const gridEl = document.getElementById('grid-lock');
                if (!gridEl) return;

                const cells = gridEl.querySelectorAll('.grid-cell');
                cells.forEach(c => {
                    c.classList.remove('focus');
                    c.classList.remove('neighbor');
                });

                if (!node) return;

                const pos = this.snap(node.x, node.y);
                const baseRow = pos.row;
                const baseCol = pos.col;
                const baseIdx = pos.cellIndex;

                if (cells[baseIdx]) {
                    cells[baseIdx].classList.add('focus');
                }

                for (let r = baseRow - 1; r <= baseRow + 1; r++) {
                    for (let c = baseCol - 1; c <= baseCol + 1; c++) {
                        if (r < 0 || r > 8 || c < 0 || c > 8) continue;
                        if (r === baseRow && c === baseCol) continue;
                        const idx = r * 9 + c;
                        if (cells[idx]) {
                            cells[idx].classList.add('neighbor');
                        }
                    }
                }
            }
        };

        // =========================================
        // ICONS
        // =========================================
        const ICONS = {
            getIsoCube(color = "blue", opacity = 1) {
                const colors = {
                    blue: { top: '#60a5fa', left: '#3b82f6', right: '#2563eb' },
                    yellow: { top: '#fcd34d', left: '#f59e0b', right: '#d97706' },
                    cyan: { top: '#22d3ee', left: '#06b6d4', right: '#0891b2' },
                    purple: { top: '#e879f9', left: '#c026d3', right: '#a21caf' },
                    green: { top: '#4ade80', left: '#16a34a', right: '#15803d' },
                    red: { top: '#f87171', left: '#ef4444', right: '#dc2626' }
                };
                const c = colors[color] || colors.blue;
                return `
                <svg viewBox="0 0 40 40" class="w-full h-full drop-shadow-lg" style="opacity: ${opacity}">
                    <path d="M20 4 L36 12 L20 20 L4 12 Z" fill="${c.top}" stroke="#1e293b" stroke-width="1" />
                    <path d="M4 12 L20 20 L20 38 L4 30 Z" fill="${c.left}" stroke="#1e293b" stroke-width="1" />
                    <path d="M36 12 L20 20 L20 38 L36 30 Z" fill="${c.right}" stroke="#1e293b" stroke-width="1" />
                </svg>`;
            },

            Entity: () => ICONS.getIsoCube('blue'),
            Core: () => ICONS.getIsoCube('yellow'),
            Goal: () => `<div class="relative w-full h-full">${ICONS.getIsoCube('green')}<div class="absolute -top-2 left-1/2 transform -translate-x-1/2 text-yellow-400 animate-pulse"><i class="fas fa-bullseye"></i></div></div>`,
            Obstacle: () => `<div class="relative w-full h-full">${ICONS.getIsoCube('red')}<div class="absolute right-0 top-1/2 transform -translate-y-1/2 w-0.5 h-full bg-red-400"></div></div>`,
            Morphism: () => `<div class="relative w-full h-full flex items-center justify-between px-1"><div class="w-4 h-4">${ICONS.getIsoCube('cyan')}</div><div class="flex-1 h-0.5 bg-cyan-400 mx-1 relative"><div class="absolute right-0 -top-1 w-0 h-0 border-l-4 border-l-cyan-400 border-t-2 border-t-transparent border-b-2 border-b-transparent"></div></div><div class="w-4 h-4">${ICONS.getIsoCube('cyan')}</div></div>`,
            Shift: () => `<div class="relative w-full h-full flex items-center justify-center"><div class="w-5 h-5 opacity-50">${ICONS.getIsoCube('cyan')}</div><div class="absolute z-10 text-yellow-400 drop-shadow-[0_0_8px_rgba(250,204,21,0.8)]"><i class="fas fa-bolt w-5 h-5 fill-current"></i></div><div class="w-5 h-5 opacity-50">${ICONS.getIsoCube('cyan')}</div></div>`,
            Location: () => `<div class="relative w-full h-full flex items-center justify-center"><div class="absolute top-0 right-0 w-4 h-4">${ICONS.getIsoCube('purple')}</div><div class="absolute bottom-0 left-0 w-4 h-4">${ICONS.getIsoCube('purple')}</div><svg class="absolute inset-0 w-full h-full pointer-events-none"><path d="M14 26 C 14 26, 20 20, 26 14" stroke="#c084fc" stroke-width="2" fill="none" stroke-linecap="round" /><polygon points="26 14, 22 15, 25 18" fill="#c084fc" /></svg></div>`,
            Timepoint: () => `<div class="relative w-full h-full flex items-center justify-center"><div class="w-3/4 h-3/4">${ICONS.getIsoCube('cyan')}</div><div class="absolute -right-1 -bottom-1 w-5 h-5 bg-[#0f172a] rounded-full border border-cyan-500 flex items-center justify-center"><i class="fas fa-clock w-3 h-3 text-cyan-400"></i></div></div>`,
            Scene: () => `<div class="relative w-full h-full flex items-center justify-center p-1"><div class="absolute top-0 left-0 w-2 h-2 border-l-2 border-t-2 border-purple-400"></div><div class="absolute top-0 right-0 w-2 h-2 border-r-2 border-t-2 border-purple-400"></div><div class="absolute bottom-0 left-0 w-2 h-2 border-l-2 border-b-2 border-purple-400"></div><div class="absolute bottom-0 right-0 w-2 h-2 border-r-2 border-b-2 border-purple-400"></div><div class="flex gap-0.5"><div class="w-3 h-3">${ICONS.getIsoCube('purple', 0.7)}</div><div class="w-3 h-3">${ICONS.getIsoCube('purple', 0.7)}</div></div></div>`,
            Story: () => `<div class="relative w-full h-full flex flex-col items-center justify-start pt-1"><div class="w-4 h-4 z-10">${ICONS.getIsoCube('purple')}</div><div class="w-0.5 h-2 bg-purple-500/50"></div><div class="w-full h-0.5 bg-purple-500/50 relative"><div class="absolute left-0 bottom-0 w-0.5 h-2 bg-purple-500/50 transform translate-y-full"></div><div class="absolute right-0 bottom-0 w-0.5 h-2 bg-purple-500/50 transform translate-y-full"></div><div class="absolute left-1/2 bottom-0 w-0.5 h-2 bg-purple-500/50 transform translate-y-full -translate-x-1/2"></div></div><div class="flex gap-1 mt-2"><div class="w-2.5 h-2.5">${ICONS.getIsoCube('cyan', 0.6)}</div><div class="w-2.5 h-2.5">${ICONS.getIsoCube('cyan', 0.6)}</div><div class="w-2.5 h-2.5">${ICONS.getIsoCube('cyan', 0.6)}</div></div></div>`
        };

        // =========================================
        // COMPILER
        // =========================================
        const COMPILER = {
            commit() {
                const input = document.getElementById('narrative-input');
                const cmd = input.value.trim();
                if (!cmd) return;

                // Commands: "make Alice Goal", "set Castle as Location"
                const typeCmd = cmd.match(/^(make|set)\s+(.+?)\s+(as\s+)?(Entity|Core|Goal|Obstacle|Morphism|Shift|Location|Timepoint|Scene|Story)$/i);
                if (typeCmd) {
                    const name = typeCmd[2].trim();
                    const typeLabel = typeCmd[4];
                    this.setTypeByName(name, typeLabel);
                    input.value = '';
                    return;
                }

                // Commands: "Alice has goal Escape", "give Alice goal Escape"
                const goalCmd = cmd.match(/^(.+?)\s+has\s+goal\s+(.+)/i) || cmd.match(/^(give|set)\s+(.+?)\s+goal\s+(.+)/i);
                if (goalCmd) {
                    let subject, object;
                    if (goalCmd.length === 3) {
                        subject = goalCmd[1].trim();
                        object = goalCmd[2].trim();
                    } else {
                        subject = goalCmd[2].trim();
                        object = goalCmd[3].trim();
                    }
                    this.decompose(subject, 'wants', object);
                    input.value = '';
                    return;
                }

                // Commands: "attach Alice to location Castle", "place Alice in Castle"
                const locCmd = cmd.match(/^attach\s+(.+?)\s+to\s+location\s+(.+)/i) || cmd.match(/^place\s+(.+?)\s+in\s+(.+)/i);
                if (locCmd) {
                    const subject = locCmd[1].trim();
                    const place = locCmd[2].trim();
                    const subId = this.findOrSpawn(subject, 'Entity');
                    const locId = this.findOrSpawn(place, 'Location');

                    if (!STATE.links.find(l => l.from === subId && l.to === locId && l.type === 'inside')) {
                        STATE.links.push({ from: subId, to: locId, type: 'inside' });
                    }

                    RENDERER.connections();
                    PERSISTENCE.save();
                    LOG.toast(`Placed ${subject} in ${place}`);
                    input.value = '';
                    return;
                }

                // Parse natural language: "A wants B" / "A opposes B" / "A becomes B"
                const regex = /(.+?)\s+(wants|opposes|becomes|is inside)\s+(.+)/i;
                const match = cmd.match(regex);

                if (match) {
                    const [_, subject, relation, object] = match;
                    this.decompose(subject, relation, object);
                } else {
                    // Fallback: spawn entity
                    this.spawnNode('Entity', cmd);
                }

                input.value = '';
            },

            setTypeByName(name, typeLabel) {
                const canonical = typeLabel.charAt(0).toUpperCase() + typeLabel.slice(1).toLowerCase();
                const node = STATE.nodes.find(n => n.label.toLowerCase() === name.toLowerCase());

                if (node) {
                    node.type = canonical.toLowerCase();
                    node.icon = canonical;
                    RENDERER.nodes();
                    PERSISTENCE.save();
                    LOG.toast(`Set ${node.label} as ${canonical}`);
                } else {
                    this.spawnNode(canonical, name);
                    LOG.toast(`Created ${canonical} "${name}"`);
                }
            },

            decompose(subName, rel, objName) {
                const subId = this.findOrSpawn(subName, 'Entity');

                let objType = 'Entity';
                if (rel === 'wants') objType = 'Goal';
                if (rel === 'opposes') objType = 'Obstacle';
                if (rel === 'is inside') objType = 'Location';

                const objId = this.findOrSpawn(objName, objType);

                // Create link
                let type = 'morphism';
                if (rel === 'wants') type = 'desire';
                if (rel === 'opposes') type = 'conflict';
                if (rel === 'is inside') type = 'inside';
                if (rel === 'becomes') type = 'shift';

                if (!STATE.links.find(l => l.from === subId && l.to === objId)) {
                    STATE.links.push({ from: subId, to: objId, type });
                }

                RENDERER.connections();
                PERSISTENCE.save();
                LOG.info(`Linked: ${subName} ‚Üí ${objName}`);
            },

            findOrSpawn(name, type) {
                const existing = STATE.nodes.find(n => n.label.toLowerCase() === name.toLowerCase());
                if (existing) return existing.id;
                return this.spawnNode(type, name);
            },

            spawnNode(type, label) {
                const id = Date.now() + Math.random();

                // Smart placement: find non-overlapping position
                let attempts = 0;
                let snapped;
                do {
                    const jitterX = 50 + (Math.random() * 40 - 20);
                    const jitterY = 50 + (Math.random() * 40 - 20);
                    snapped = GRID.snap(jitterX, jitterY);
                    attempts++;
                } while (this.hasCollision(snapped) && attempts < 50);

                const newNode = {
                    id,
                    type: type.toLowerCase(),
                    icon: type,
                    label: label || type,
                    x: snapped.x,
                    y: snapped.y
                };

                STATE.nodes.push(newNode);
                RENDERER.nodes();
                RENDERER.connections();
                PERSISTENCE.save();

                return id;
            },

            hasCollision(pos) {
                // Check if position is occupied (within same grid cell)
                return STATE.nodes.some(node => {
                    const nodeCellX = Math.round(node.x / (100 / 9));
                    const nodeCellY = Math.round(node.y / (100 / 9));
                    const posCellX = Math.round(pos.x / (100 / 9));
                    const posCellY = Math.round(pos.y / (100 / 9));
                    return nodeCellX === posCellX && nodeCellY === posCellY;
                });
            },

            loadScenario(type) {
                STATE.nodes = [];
                STATE.links = [];

                if (type === 'heist') {
                    this.decompose('The Crew', 'wants', 'The Diamond');
                    this.decompose('The Guards', 'opposes', 'The Crew');
                    this.decompose('The Vault', 'is inside', 'The Bank');
                } else if (type === 'romance') {
                    this.decompose('Romeo', 'wants', 'Juliet');
                    this.decompose('Tybalt', 'opposes', 'Romeo');
                    this.decompose('Fate', 'opposes', 'Romeo');
                }

                if (STATE.viewMode === 'story') {
                    VIEW_MODE.arrangeAsTree();
                }

                LOG.success(`Loaded ${type} scenario`);
            }
        };

        // =========================================
        // RENDERER
        // =========================================
        const RENDERER = {
            nodes() {
                const container = document.getElementById('nodes-layer');
                container.innerHTML = STATE.nodes.map(node => {
                    const isSelected = STATE.selectedNodeId === node.id;
                    const iconFn = ICONS[node.icon] || ICONS.Entity;
                    return `
                    <div class="node-instance ${isSelected ? 'selected' : ''}" 
                         style="left: ${node.x}%; top: ${node.y}%; pointer-events: auto;"
                         data-node-id="${node.id}"
                         onmousedown="EVENTS.startDrag(event, ${node.id})"
                         ontouchstart="EVENTS.startDrag(event, ${node.id})"
                         onclick="INSPECTOR.select(${node.id})"
                         ondblclick="INSPECTOR.selectAndFocus(${node.id})"
                         oncontextmenu="INSPECTOR.onContextMenu(event, ${node.id})">
                        <div class="node-halo"></div>
                        <div class="w-16 h-16 drop-shadow-2xl">
                            ${iconFn()}
                        </div>
                        <div class="absolute -bottom-6 left-1/2 transform -translate-x-1/2 whitespace-nowrap px-2 py-0.5 bg-[var(--theme-panel)]/90 border border-cyan-500/30 rounded text-[10px] text-cyan-400 pointer-events-none">
                            ${node.label}
                        </div>
                    </div>`;
                }).join('');

                document.getElementById('node-count').textContent = STATE.nodes.length;
                document.getElementById('link-count').textContent = STATE.links.length;
            },

            // Event listeners for buttons, placed here for now
            // TODO: Move to a dedicated EVENTS object or similar if this grows
            initEventListeners() {
                const btnTree = document.getElementById('btn-tree');
                const btnForce = document.getElementById('btn-force');
                const btnReset = document.getElementById('btn-reset');
                const btnExportFrank = document.getElementById('btn-export-frank');
                const btnExportMpd = document.getElementById('btn-export-mpd');

                if (btnTree) {
                    btnTree.addEventListener('click', () => {
                        STATE.viewMode = 'story';
                        VIEW_MODE.arrangeAsTree();
                    });
                }

                if (btnForce) {
                    btnForce.addEventListener('click', () => {
                        STATE.viewMode = 'graph';
                        VIEW_MODE.arrangeAsForce();
                    });
                }

                if (btnReset) {
                    btnReset.addEventListener('click', () => {
                        if (confirm('Clear all nodes and links? This cannot be undone.')) {
                            STATE.nodes = [];
                            STATE.links = [];
                            STATE.selectedNodeId = null;

                            // Remove background image
                            const bgImg = document.getElementById('gar-background-img');
                            if (bgImg) bgImg.remove();

                            RENDERER.nodes();
                            RENDERER.connections();
                            INSPECTOR.clear();
                            PERSISTENCE.save();
                            LOG.success('Grid reset');
                        }
                    });
                }

                if (btnExportFrank) {
                    btnExportFrank.addEventListener('click', () => {
                        this.exportFrank();
                    });
                }

                if (btnExportMpd) {
                    btnExportMpd.addEventListener('click', () => {
                        this.exportMPD();
                    });
                }
            },

            // Export to Frank JSON format
            exportFrank() {
                const scene = {
                    id: `scene-${Date.now()}`,
                    name: 'TAO Narrative Export',
                    description: 'Exported from GAR-TAO',
                    timestamp: Date.now(),
                    variant: 'tao',
                    grid: [], // Will be populated
                    inbox: [],
                    meta: {
                        source: 'gar-tao',
                        gridSize: 20
                    }
                };

                // Populate grid (20x20 = 400 cells)
                // Initialize empty grid
                for (let i = 0; i < 400; i++) {
                    scene.grid.push({
                        id: i,
                        occupantId: null
                    });
                }

                // Map nodes to grid cells
                STATE.nodes.forEach(node => {
                    // Convert percentage back to grid index
                    // x is 0-100, grid is 0-19
                    const gridX = Math.round((node.x / 100) * 19);
                    const gridY = Math.round((node.y / 100) * 19);
                    const index = gridY * 20 + gridX;

                    if (index >= 0 && index < 400) {
                        scene.grid[index].occupantId = node.id;

                        // Add node data to inbox as "packet"
                        scene.inbox.push({
                            id: node.id,
                            kind: 'entity',
                            label: node.label,
                            type: node.type,
                            payload: node.data
                        });
                    }
                });

                // Add links to inbox as metadata
                scene.inbox.push({
                    id: `links-${Date.now()}`,
                    kind: 'connections',
                    payload: STATE.links
                });

                // Download file
                const blob = new Blob([JSON.stringify(scene, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `tao-frank-export-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                LOG.success('Exported Frank JSON');
            },

            // Export to LDraw MPD format
            exportMPD() {
                const filename = `tao_narrative_${Date.now()}.mpd`;
                const lines = [];

                // Header
                lines.push(`0 FILE ${filename}`);
                lines.push(`0 Name: ${filename}`);
                lines.push(`0 Author: TAO System`);
                lines.push(`0 !LDRAW_ORG Model`);
                lines.push(`0 !LICENSE Redistributable under CCAL version 2.0`);
                lines.push(`0 BFC CERTIFY CCW`);
                lines.push(``);
                lines.push(`0 // TAO NARRATIVE STRUCTURE`);
                lines.push(`0 // Nodes: ${STATE.nodes.length} | Links: ${STATE.links.length}`);
                lines.push(``);

                // Map node types to LDraw parts and colors
                const typeMap = {
                    'entity': { part: '3001.dat', color: 4 }, // Red Brick 2x4
                    'goal': { part: '3003.dat', color: 2 },   // Green Brick 2x2
                    'obstacle': { part: '3004.dat', color: 1 }, // Blue Brick 1x2
                    'core': { part: '3005.dat', color: 14 },  // Yellow Brick 1x1
                    'default': { part: '3005.dat', color: 15 } // White Brick 1x1
                };

                // Scale factor: TAO 0-100% -> LDraw units (e.g., -400 to 400)
                const SCALE = 8;
                const OFFSET = -400;

                STATE.nodes.forEach(node => {
                    const typeInfo = typeMap[node.type] || typeMap['default'];
                    const x = (node.x * SCALE) + OFFSET;
                    const z = (node.y * SCALE) + OFFSET; // Map Y to Z (top-down view)
                    const y = 0; // Flat plane

                    lines.push(`0 // Node: ${node.label} (${node.type})`);
                    // LDraw Line: 1 <colour> <x> <y> <z> <a b c d e f g h i> <file>
                    lines.push(`1 ${typeInfo.color} ${x.toFixed(2)} ${y} ${z.toFixed(2)} 1 0 0 0 1 0 0 0 1 ${typeInfo.part}`);
                });

                lines.push(``);
                lines.push(`0 // CONNECTIONS`);

                STATE.links.forEach(link => {
                    const n1 = STATE.nodes.find(n => n.id === link.from);
                    const n2 = STATE.nodes.find(n => n.id === link.to);
                    if (n1 && n2) {
                        lines.push(`0 // Link: ${n1.label} -> ${n2.label} (${link.type})`);
                    }
                });

                lines.push(``);
                lines.push(`0 NOFILE`);

                // Download file
                const blob = new Blob([lines.join('\n')], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                LOG.success('Exported LDraw MPD');
            },

            connections() {
                const svg = document.getElementById('connections-layer');
                if (!svg) return;

                svg.innerHTML = '';

                STATE.links.forEach(link => {
                    const n1 = STATE.nodes.find(n => n.id === link.from);
                    const n2 = STATE.nodes.find(n => n.id === link.to);
                    if (!n1 || !n2) return;

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                    // Use percentage coordinates directly (0-100 range matches viewBox)
                    const x1 = n1.x;
                    const y1 = n1.y;
                    const x2 = n2.x;
                    const y2 = n2.y;

                    const cx = (x1 + x2) / 2;
                    const cy = (y1 + y2) / 2 - 3; // Slight curve
                    const d = `M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}`;

                    path.setAttribute('d', d);

                    let color = '#fff';
                    if (link.type === 'desire') color = '#fcd34d';
                    if (link.type === 'conflict') color = '#f87171';
                    if (link.type === 'morphism') color = '#22d3ee';
                    if (link.type === 'flow') color = '#4ade80';

                    path.setAttribute('stroke', color);
                    path.setAttribute('stroke-width', '0.5');
                    path.setAttribute('stroke-opacity', '0.7');
                    path.setAttribute('fill', 'none');

                    if (link.type === 'morphism') path.setAttribute('stroke-dasharray', '2 1');

                    svg.appendChild(path);
                });
            },

            preview() {
                const container = document.getElementById('preview-content');
                container.innerHTML = `
                <div class="max-w-2xl mx-auto">
                    <h1 class="text-3xl font-bold mb-6 text-[var(--theme-core)]">Narrative Structure</h1>
                    ${STATE.nodes.map(node => `
                        <div class="mb-4 p-4 bg-[var(--theme-surface)] border border-[var(--theme-border)] rounded-lg">
                            <div class="flex items-center gap-2 mb-2">
                                <div class="w-8 h-8">${ICONS[node.icon]()}</div>
                                <span class="font-bold text-lg">${node.label}</span>
                                <span class="text-xs text-[var(--theme-text-muted)]">(${node.type})</span>
                            </div>
                            ${STATE.links.filter(l => l.from === node.id).map(link => {
                    const target = STATE.nodes.find(n => n.id === link.to);
                    return target ? `<div class="text-sm text-[var(--theme-text-muted)] ml-10">‚Üí ${link.type}: ${target.label}</div>` : '';
                }).join('')}
                        </div>
                    `).join('')}
                </div>`;
            },

            grid() {
                const container = document.getElementById('grid-lock');
                container.innerHTML = '';

                for (let i = 0; i < 81; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.index = i;
                    container.appendChild(cell);
                }
            }
        };

        // =========================================
        // VIEW MODE
        // =========================================
        const VIEW_MODE = {
            switch(mode) {
                STATE.viewMode = mode;

                document.querySelectorAll('.nav-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.view === mode);
                    tab.classList.toggle('text-[var(--theme-text-muted)]', tab.dataset.view !== mode);
                });

                document.getElementById('nodes-layer').style.display = mode === 'preview' ? 'none' : 'block';
                document.getElementById('preview-content').style.display = mode === 'preview' ? 'block' : 'none';

                if (mode === 'story') {
                    this.arrangeAsTree();
                } else if (mode === 'preview') {
                    RENDERER.preview();
                }

                RENDERER.connections();
                LOG.toast(`Switched to ${mode.toUpperCase()} view`);
            },

            arrangeAsTree() {
                // Simple tree layout
                const core = STATE.nodes.find(n => n.type === 'core');
                if (core) {
                    const pos = GRID.center(4, 1);
                    core.x = pos.x;
                    core.y = pos.y;
                }

                const others = STATE.nodes.filter(n => n.type !== 'core');
                const cols = [1, 3, 5, 7];
                others.forEach((n, i) => {
                    const pos = GRID.center(cols[i % cols.length], 3 + Math.floor(i / cols.length) * 2);
                    n.x = pos.x;
                    n.y = pos.y;
                });

                RENDERER.nodes();
                RENDERER.connections();
            }
        };

        // =========================================
        // SIDEBAR
        // =========================================
        const SIDEBAR = {
            renderTools() {
                const sections = [
                    {
                        name: 'Narrative',
                        id: 'narrative',
                        collapsed: false,
                        tools: [
                            { label: 'Entity', icon: 'Entity', desc: 'Actors & objects' },
                            { label: 'Core', icon: 'Core', desc: 'Central themes' },
                            { label: 'Goal', icon: 'Goal', desc: 'Desired states' },
                            { label: 'Obstacle', icon: 'Obstacle', desc: 'Blockers & conflicts' }
                        ]
                    },
                    {
                        name: 'Structure',
                        id: 'structure',
                        collapsed: true,
                        tools: [
                            { label: 'Scene', icon: 'Scene', desc: 'Spatial contexts' },
                            { label: 'Timepoint', icon: 'Timepoint', desc: 'Temporal markers' },
                            { label: 'Location', icon: 'Location', desc: 'Place & setting' },
                            { label: 'Story', icon: 'Story', desc: 'Meta-narrative' }
                        ]
                    },
                    {
                        name: 'Relations',
                        id: 'relations',
                        collapsed: true,
                        tools: [
                            { label: 'Morphism', icon: 'Morphism', desc: 'Transformations' },
                            { label: 'Shift', icon: 'Shift', desc: 'State changes' }
                        ]
                    }
                ];

                const container = document.getElementById('tools-list');
                container.innerHTML = sections.map(section => `
                    <div class="mb-3">
                        <div class="flex items-center gap-2 px-2 py-1 cursor-pointer hover:bg-[var(--theme-surface)] rounded" 
                             onclick="SIDEBAR.toggleSection('${section.id}')">
                            <i id="icon-${section.id}" class="fas fa-${section.collapsed ? 'chevron-right' : 'chevron-down'} w-3 h-3 text-[var(--theme-text-muted)] transition-transform"></i>
                            <span class="text-xs font-bold text-[var(--theme-text-muted)] uppercase tracking-wide">${section.name}</span>
                            <span class="ml-auto text-[10px] text-[var(--theme-text-muted)]">${section.tools.length}</span>
                        </div>
                        <div id="section-${section.id}" class="${section.collapsed ? 'hidden' : ''} mt-1 space-y-1">
                            ${section.tools.map(tool => `
                                <div class="tool-item group" onclick="COMPILER.spawnNode('${tool.icon}', '${tool.label}')" title="${tool.desc}">
                                    <div class="w-8 h-8">${ICONS[tool.icon]()}</div>
                                    <div class="flex flex-col flex-1">
                                        <span class="text-sm">${tool.label}</span>
                                        <span class="text-[10px] text-[var(--theme-text-muted)] opacity-0 group-hover:opacity-100 transition-opacity">${tool.desc}</span>
                                    </div>
                                    <div class="ml-auto text-[var(--theme-text-muted)]">
                                        <i class="fas fa-plus w-3 h-3"></i>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `).join('');
            },

            toggleSection(id) {
                const section = document.getElementById(`section-${id}`);
                const icon = document.getElementById(`icon-${id}`);
                if (section.classList.contains('hidden')) {
                    section.classList.remove('hidden');
                    icon.classList.remove('fa-chevron-right');
                    icon.classList.add('fa-chevron-down');
                } else {
                    section.classList.add('hidden');
                    icon.classList.remove('fa-chevron-down');
                    icon.classList.add('fa-chevron-right');
                }
            }
        };

        // =========================================
        // INSPECTOR
        // =========================================
        const INSPECTOR = {
            select(id) {
                STATE.selectedNodeId = id;
                RENDERER.nodes();

                const node = STATE.nodes.find(n => n.id === id);
                if (!node) return;

                GRID.highlightNeighborhood(node);

                // Compute nearby/overlapping nodes for suggestions
                const nodeCell = GRID.snap(node.x, node.y);
                const others = STATE.nodes.filter(n => n.id !== node.id);
                const sameCell = [];
                const neighbors = [];

                others.forEach(other => {
                    const pos = GRID.snap(other.x, other.y);
                    const distRow = Math.abs(pos.row - nodeCell.row);
                    const distCol = Math.abs(pos.col - nodeCell.col);
                    if (distRow === 0 && distCol === 0) {
                        sameCell.push(other);
                    } else if (distRow <= 1 && distCol <= 1) {
                        neighbors.push(other);
                    }
                });

                const locations = STATE.nodes.filter(n => n.icon === 'Location');
                const goals = STATE.nodes.filter(n => n.icon === 'Goal');

                const hasDesire = STATE.links.some(l => l.from === node.id && l.type === 'desire');
                const hasLocationLink = STATE.links.some(l => {
                    if (l.from !== node.id || l.type !== 'inside') return false;
                    const target = STATE.nodes.find(n => n.id === l.to);
                    return target && target.icon === 'Location';
                });

                const content = document.getElementById('inspector-content');
                content.innerHTML = `
                    <div class="space-y-4 animate-fade-up">
                        <div class="p-3 rounded bg-[var(--theme-surface)] border border-[var(--theme-border)]">
                            <div class="text-[10px] uppercase tracking-wider text-[var(--theme-text-muted)] mb-2">Label</div>
                            <input type="text" value="${node.label}" 
                                   onchange="INSPECTOR.updateLabel(${node.id}, this.value)"
                                   class="w-full bg-transparent border-b border-[var(--theme-border)] focus:border-cyan-500 outline-none text-white" />
                        </div>
                        <div class="p-3 rounded bg-[var(--theme-surface)] border border-[var(--theme-border)]">
                            <div class="text-[10px] uppercase tracking-wider text-[var(--theme-text-muted)] mb-2">Type</div>
                            <select 
                                onchange="INSPECTOR.updateType(${node.id}, this.value)"
                                class="w-full bg-transparent border border-[var(--theme-border)] rounded px-2 py-1 text-xs">
                                <option value="Entity" ${node.icon === 'Entity' ? 'selected' : ''}>Entity</option>
                                <option value="Core" ${node.icon === 'Core' ? 'selected' : ''}>Core</option>
                                <option value="Goal" ${node.icon === 'Goal' ? 'selected' : ''}>Goal</option>
                                <option value="Obstacle" ${node.icon === 'Obstacle' ? 'selected' : ''}>Obstacle</option>
                                <option value="Morphism" ${node.icon === 'Morphism' ? 'selected' : ''}>Morphism</option>
                                <option value="Shift" ${node.icon === 'Shift' ? 'selected' : ''}>Shift</option>
                                <option value="Location" ${node.icon === 'Location' ? 'selected' : ''}>Location</option>
                                <option value="Timepoint" ${node.icon === 'Timepoint' ? 'selected' : ''}>Timepoint</option>
                                <option value="Scene" ${node.icon === 'Scene' ? 'selected' : ''}>Scene</option>
                                <option value="Story" ${node.icon === 'Story' ? 'selected' : ''}>Story</option>
                            </select>
                        </div>
                        <div class="p-3 rounded bg-[var(--theme-surface)] border border-[var(--theme-border)]">
                            <div class="text-[10px] uppercase tracking-wider text-[var(--theme-text-muted)] mb-2">Actions</div>
                            <button onclick="INSPECTOR.forkScene()"
                                class="w-full py-2 bg-[var(--theme-surface)] border border-[var(--theme-border)] rounded-md text-[10px] font-semibold uppercase tracking-wide hover:border-[var(--theme-core)]">
                                Fork scene from this
                            </button>
                        </div>
                        <div class="p-3 rounded bg-[var(--theme-surface)] border border-[var(--theme-border)]">
                            <div class="text-[10px] uppercase tracking-wider text-[var(--theme-text-muted)] mb-2">Links</div>
                            <div class="text-xs space-y-1">
                                ${STATE.links.filter(l => l.from === node.id || l.to === node.id).map(link => {
                    const isOut = link.from === node.id;
                    const other = STATE.nodes.find(n => n.id === (isOut ? link.to : link.from));
                    return other ? `<div>${isOut ? '‚Üí' : '‚Üê'} ${link.type}: ${other.label}</div>` : '';
                }).join('') || '<div class="text-[var(--theme-text-muted)]">No links</div>'}
                            </div>
                        </div>
                        <div class="p-3 rounded bg-[var(--theme-surface)] border border-[var(--theme-border)]">
                            <div class="text-[10px] uppercase tracking-wider text-[var(--theme-text-muted)] mb-2">Suggestions</div>
                            <div class="text-[10px] text-[var(--theme-text-muted)]">Click to weave relations around this entity.</div>
                            ${sameCell.length ? `
                            <div class="mt-2 text-[10px] text-[var(--theme-text-muted)]">Overlaps in this cell</div>
                            <div class="mt-1 flex flex-wrap gap-1">
                                ${sameCell.map(o => `
                                    <button onclick="INSPECTOR.createLink(${node.id}, ${o.id}, 'morphism')"
                                        class="px-2 py-1 rounded border border-[var(--theme-border)] text-[10px] hover:border-[var(--theme-core)]">
                                        ‚Üî ${o.label}
                                    </button>
                                `).join('')}
                            </div>` : ''}

                            ${neighbors.length ? `
                            <div class="mt-2 text-[10px] text-[var(--theme-text-muted)]">Nearby (3√ó3 neighborhood)</div>
                            <div class="mt-1 flex flex-wrap gap-1">
                                ${neighbors.map(o => {
                    const alreadyLinked = STATE.links.some(l => (l.from === node.id && l.to === o.id) || (l.from === o.id && l.to === node.id));
                    if (alreadyLinked) return '';
                    return `
                                        <button onclick="INSPECTOR.createLink(${node.id}, ${o.id}, 'morphism')"
                                            class="px-2 py-1 rounded border border-[var(--theme-border)] text-[10px] hover:border-[var(--theme-core)]">
                                            ¬∑ ${o.label}
                                        </button>
                                    `;
                }).join('')}
                            </div>` : ''}

                            ${(!hasLocationLink && locations.length) ? `
                            <div class="mt-2 text-[10px] text-[var(--theme-text-muted)]">Location assumptions</div>
                            <div class="mt-1 flex flex-wrap gap-1">
                                ${locations.map(loc => `
                                    <button onclick="INSPECTOR.attachToLocation(${node.id}, ${loc.id})"
                                        class="px-2 py-1 rounded border border-[var(--theme-border)] text-[10px] hover:border-[var(--theme-core)]">
                                        Place in ${loc.label}
                                    </button>
                                `).join('')}
                            </div>` : ''}

                            ${(!hasDesire && goals.length && node.icon === 'Entity') ? `
                            <div class="mt-2 text-[10px] text-[var(--theme-text-muted)]">Goal assumptions</div>
                            <div class="mt-1 flex flex-wrap gap-1">
                                ${goals.map(g => `
                                    <button onclick="INSPECTOR.giveGoal(${node.id}, ${g.id})"
                                        class="px-2 py-1 rounded border border-[var(--theme-border)] text-[10px] hover:border-[var(--theme-core)]">
                                        Give goal ${g.label}
                                    </button>
                                `).join('')}
                            </div>` : ''}
                        </div>
                    </div>
                `;
            },

            updateLabel(id, value) {
                const node = STATE.nodes.find(n => n.id === id);
                if (node) {
                    node.label = value;
                    RENDERER.nodes();
                    PERSISTENCE.save();
                    LOG.toast('Label updated');
                }
            },

            delete() {
                if (!STATE.selectedNodeId) return;

                STATE.nodes = STATE.nodes.filter(n => n.id !== STATE.selectedNodeId);
                STATE.links = STATE.links.filter(l => l.from !== STATE.selectedNodeId && l.to !== STATE.selectedNodeId);
                STATE.selectedNodeId = null;

                RENDERER.nodes();
                RENDERER.connections();
                this.close();
                PERSISTENCE.save();
                LOG.toast('Entity deleted');
            },

            close() {
                STATE.selectedNodeId = null;
                document.getElementById('inspector-content').innerHTML = `
                    <div class="text-sm text-[var(--theme-text-muted)] text-center py-8">
                        Select a node to inspect
                    </div>`;
                RENDERER.nodes();
                GRID.highlightNeighborhood(null);
            },

            updateType(id, typeLabel) {
                const node = STATE.nodes.find(n => n.id === id);
                if (!node) return;

                const canonical = typeLabel.charAt(0).toUpperCase() + typeLabel.slice(1).toLowerCase();
                node.type = canonical.toLowerCase();
                node.icon = canonical;

                RENDERER.nodes();
                PERSISTENCE.save();
                LOG.toast(`Type set to ${canonical}`);
            },

            forkScene() {
                if (!STATE.selectedNodeId) return;
                const node = STATE.nodes.find(n => n.id === STATE.selectedNodeId);
                if (!node) return;

                if (!SCENE_IO.collection || !Array.isArray(SCENE_IO.collection.scenes)) {
                    LOG.warn('No SceneCollection loaded; cannot fork scene');
                    LOG.toast('Load scenes via Merge before forking');
                    return;
                }

                const base = SCENE_IO.collection.scenes[SCENE_IO.currentIndex];
                if (!base) return;

                const clone = JSON.parse(JSON.stringify(base));
                const baseTitle = base.title || base.label || base.id || 'Scene';
                const nodeLabel = node.label || node.icon || 'node';

                clone.id = (base.id ? `${base.id}_fork_${Date.now()}` : `scene_fork_${Date.now()}`);
                clone.title = `${baseTitle} ¬∑ Fork of ${nodeLabel}`;
                clone.meta = clone.meta || {};
                clone.meta.isFork = true;
                clone.meta.forkOf = base.id || baseTitle;
                clone.meta.forkSourceLabel = nodeLabel;

                SCENE_IO.collection.scenes.push(clone);
                SCENE_IO.currentIndex = SCENE_IO.collection.scenes.length - 1;
                SCENE_IO.saveToLocalStorage();
                SCENE_IO.populatePicker();
                SCENE_IO.loadScene(SCENE_IO.currentIndex);

                LOG.success(`Forked new scene from "${nodeLabel}"`);
            },

            selectAndFocus(id) {
                this.select(id);
                LOG.toast('Inspector ready: adjust type or fork scene');
            },

            onContextMenu(e, id) {
                e.preventDefault();
                this.select(id);
                LOG.toast('Inspector options available for this entity');
            },

            createLink(fromId, toId, typeLabel) {
                const type = typeLabel || 'morphism';
                if (STATE.links.find(l => l.from === fromId && l.to === toId && l.type === type)) return;

                STATE.links.push({ from: fromId, to: toId, type });
                RENDERER.connections();
                PERSISTENCE.save();
                LOG.toast('Link created');

                if (STATE.selectedNodeId === fromId) this.select(fromId);
            },

            attachToLocation(nodeId, locId) {
                const node = STATE.nodes.find(n => n.id === nodeId);
                const loc = STATE.nodes.find(n => n.id === locId);
                if (!node || !loc) return;

                if (!STATE.links.some(l => l.from === nodeId && l.to === locId && l.type === 'inside')) {
                    STATE.links.push({ from: nodeId, to: locId, type: 'inside' });
                }

                RENDERER.connections();
                PERSISTENCE.save();
                LOG.toast(`Placed ${node.label} in ${loc.label}`);

                if (STATE.selectedNodeId === nodeId) this.select(nodeId);
            },

            giveGoal(nodeId, goalId) {
                const node = STATE.nodes.find(n => n.id === nodeId);
                const goal = STATE.nodes.find(n => n.id === goalId);
                if (!node || !goal) return;

                if (!STATE.links.some(l => l.from === nodeId && l.to === goalId && l.type === 'desire')) {
                    STATE.links.push({ from: nodeId, to: goalId, type: 'desire' });
                }

                RENDERER.connections();
                PERSISTENCE.save();
                LOG.toast(`Gave ${node.label} goal ${goal.label}`);

                if (STATE.selectedNodeId === nodeId) this.select(nodeId);
            }
        };

        // =========================================
        // EVENTS
        // =========================================
        const EVENTS = {
            startDrag(e, id) {
                e.stopPropagation();
                STATE.draggedNodeId = id;

                const evt = e.touches ? e.touches[0] : e;
                STATE.lastX = evt.clientX;
                STATE.lastY = evt.clientY;

                document.body.style.cursor = 'grabbing';
            },

            handleDragMove(e) {
                if (!STATE.draggedNodeId) return;
                e.preventDefault();

                const evt = e.touches ? e.touches[0] : e;
                const deltaX = evt.clientX - STATE.lastX;
                const deltaY = evt.clientY - STATE.lastY;

                STATE.lastX = evt.clientX;
                STATE.lastY = evt.clientY;

                const canvasRect = document.getElementById('grid-shell').getBoundingClientRect();
                const percentX = (deltaX / canvasRect.width) * 100;
                const percentY = (deltaY / canvasRect.height) * 100;

                const node = STATE.nodes.find(n => n.id === STATE.draggedNodeId);
                if (node) {
                    node.x = Math.max(0, Math.min(100, node.x + percentX));
                    node.y = Math.max(0, Math.min(100, node.y + percentY));

                    const el = document.querySelector(`[data-node-id="${node.id}"]`);
                    if (el) {
                        el.style.left = `${node.x}%`;
                        el.style.top = `${node.y}%`;
                    }

                    RENDERER.connections();
                }
            },

            handleDragEnd() {
                if (!STATE.draggedNodeId) return;

                const node = STATE.nodes.find(n => n.id === STATE.draggedNodeId);
                if (node) {
                    const snapped = GRID.snap(node.x, node.y);
                    node.x = snapped.x;
                    node.y = snapped.y;

                    const el = document.querySelector(`[data-node-id="${node.id}"]`);
                    if (el) {
                        el.style.left = `${node.x}%`;
                        el.style.top = `${node.y}%`;
                    }
                }

                STATE.draggedNodeId = null;
                document.body.style.cursor = 'default';
                RENDERER.connections();
                GRID.highlightNeighborhood(node || null);
                PERSISTENCE.save();
            }
        };

        // =========================================
        // THEME
        // =========================================
        const THEME = {
            set(mode) {
                document.body.className = document.body.className.replace(/theme-\w+/, '') + ` theme-${mode} grid grid-cols-[288px_1fr_320px] grid-rows-[64px_1fr_200px] h-screen w-screen overflow-hidden`;
                STATE.theme = mode;
                document.querySelectorAll('.theme-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.theme === mode);
                    btn.classList.toggle('text-[var(--theme-text-muted)]', btn.dataset.theme !== mode);
                });
                PERSISTENCE.save();
            }
        };

        // =========================================
        // CONSOLE
        // =========================================
        const CONSOLE = {
            toggle() {
                LAYOUT.toggleConsole();
            },

            log(type, msg) {
                const container = document.getElementById('console-content');
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type.toLowerCase()}`;
                entry.innerHTML = `<span class="font-bold">${type}</span> ${msg}`;
                container.prepend(entry);
            }
        };

        // =========================================
        // PERSISTENCE
        // =========================================
        const PERSISTENCE = {
            save() {
                const data = {
                    nodes: STATE.nodes,
                    links: STATE.links,
                    viewMode: STATE.viewMode,
                    theme: STATE.theme,
                    sidebarCollapsed: STATE.sidebarCollapsed,
                    inspectorCollapsed: STATE.inspectorCollapsed,
                    consoleCollapsed: STATE.consoleCollapsed
                };
                localStorage.setItem('onyx_storytelling_state', JSON.stringify(data));
            },

            load() {
                const raw = localStorage.getItem('onyx_storytelling_state');
                if (!raw) {
                    // Default setup
                    const corePos = GRID.center(4, 4);
                    STATE.nodes = [{
                        id: Date.now(),
                        type: 'core',
                        icon: 'Core',
                        label: 'Story Core',
                        x: corePos.x,
                        y: corePos.y
                    }];
                    return;
                }

                try {
                    const data = JSON.parse(raw);
                    Object.assign(STATE, data);
                } catch (e) {
                    LOG.error('Failed to load state');
                }
            }
        };

        // =========================================
        // FEEDBACK (HAPTIC / SONIC)
        // =========================================
        const FEEDBACK = {
            audioCtx: null,

            ensureAudio() {
                const AC = window.AudioContext || window.webkitAudioContext;
                if (!AC) return null;
                if (!this.audioCtx) {
                    try {
                        this.audioCtx = new AC();
                    } catch (e) {
                        this.audioCtx = null;
                    }
                }
                return this.audioCtx;
            },

            playTone(freq, durationSec) {
                const ctx = this.ensureAudio();
                if (!ctx) return;

                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.value = freq;
                osc.connect(gain);
                gain.connect(ctx.destination);

                const now = ctx.currentTime;
                gain.gain.setValueAtTime(0.0, now);
                gain.gain.linearRampToValueAtTime(0.18, now + 0.01);
                gain.gain.linearRampToValueAtTime(0.0, now + durationSec);

                osc.start(now);
                osc.stop(now + durationSec + 0.05);
            },

            pulse(pattern) {
                if (navigator.vibrate) {
                    navigator.vibrate(pattern || 10);
                }
            },

            soft() {
                this.pulse(12);
                this.playTone(420, 0.08);
            },

            success() {
                this.pulse([8, 30, 12]);
                this.playTone(660, 0.12);
            }
        };

        // =========================================
        // LOG
        // =========================================
        const LOG = {
            info(msg) { CONSOLE.log('INFO', msg); },
            success(msg) { CONSOLE.log('SUCCESS', msg); },
            warn(msg) { CONSOLE.log('WARN', msg); },
            error(msg) { CONSOLE.log('ERROR', msg); },
            toast(msg) {
                FEEDBACK.soft();
                const container = document.getElementById('toast-container');
                const toast = document.createElement('div');
                toast.className = 'toast';
                toast.innerHTML = `<i class="fas fa-check-circle w-4 h-4 text-cyan-400 mr-2"></i> ${msg}`;
                container.appendChild(toast);
                setTimeout(() => {
                    toast.style.opacity = '0';
                    setTimeout(() => toast.remove(), 300);
                }, 3000);
            }
        };

        // =========================================
        // SCENE COLLECTION BRIDGE (LEGOS ‚Üî ONYX)
        // =========================================
        const SCENE_IO = {
            collection: null,
            currentIndex: 0,

            loadFromLocalStorage() {
                try {
                    const raw = localStorage.getItem('onyx_scene_collection');
                    if (!raw) return;
                    const col = JSON.parse(raw);
                    if (!col || !Array.isArray(col.scenes)) return;
                    this.collection = col;
                    this.currentIndex = 0;
                    this.populatePicker();
                } catch (e) {
                    LOG.error('Failed to read onyx_scene_collection');
                }
            },

            populatePicker() {
                const picker = document.getElementById('scene-picker');
                if (!picker || !this.collection) return;
                picker.innerHTML = '';
                this.collection.scenes.forEach((scene, idx) => {
                    const opt = document.createElement('option');
                    const title = scene.title || scene.label || scene.id || `Scene ${idx + 1}`;
                    const isFork = scene.meta && scene.meta.isFork;
                    opt.value = String(idx);
                    opt.textContent = `${String(idx + 1).padStart(2, '0')} ¬∑ ${isFork ? '‚Ü≥ ' : ''}${title}`;
                    picker.appendChild(opt);
                });
                picker.value = String(this.currentIndex);
            },

            loadScene(index) {
                if (!this.collection || !Array.isArray(this.collection.scenes)) return;
                const scene = this.collection.scenes[index];
                if (!scene) return;

                this.currentIndex = index;

                // Reset ONYX Tail state
                STATE.nodes = [];
                STATE.links = [];

                const grid = Array.isArray(scene.grid) ? scene.grid : [];
                grid.forEach((cell, idx) => {
                    if (!cell) return;
                    const kind = cell.kind || 'Entity';
                    const icon = ICONS[kind] ? kind : 'Entity';
                    const row = Math.floor(idx / 9);
                    const col = idx % 9;
                    const pos = GRID.center(col, row);

                    const node = {
                        id: Date.now() + Math.random(),
                        type: (kind || 'Entity').toLowerCase(),
                        icon,
                        label: cell.label || cell.symbol || cell.id || kind,
                        x: pos.x,
                        y: pos.y
                    };
                    STATE.nodes.push(node);
                });

                // Track scene metadata for UI
                STATE.sceneMeta = {
                    id: scene.id || null,
                    title: scene.title || scene.label || null,
                    isFork: !!(scene.meta && scene.meta.isFork),
                    forkOf: scene.meta && scene.meta.forkOf ? scene.meta.forkOf : null,
                    forkSourceLabel: scene.meta && scene.meta.forkSourceLabel ? scene.meta.forkSourceLabel : null
                };

                const badge = document.getElementById('scene-fork-indicator');
                if (badge) {
                    if (STATE.sceneMeta.isFork && (STATE.sceneMeta.forkSourceLabel || STATE.sceneMeta.forkOf)) {
                        const src = STATE.sceneMeta.forkSourceLabel || STATE.sceneMeta.forkOf;
                        badge.textContent = `FORK ¬∑ from ${src}`;
                        badge.classList.remove('hidden');
                    } else {
                        badge.textContent = '';
                        badge.classList.add('hidden');
                    }
                }

                RENDERER.nodes();
                RENDERER.connections();
                PERSISTENCE.save();
                LOG.toast(`Loaded scene ${index + 1} into ONYX Tail`);
            },

            saveToLocalStorage() {
                if (!this.collection) return;
                try {
                    localStorage.setItem('onyx_scene_collection', JSON.stringify(this.collection));
                } catch (e) {
                    LOG.error('Failed to save onyx_scene_collection');
                }
            },

            syncFromPicker() {
                if (!this.collection) this.loadFromLocalStorage();
                const picker = document.getElementById('scene-picker');
                if (!picker || !this.collection) return;
                const idx = parseInt(picker.value, 10);
                const safeIdx = Number.isNaN(idx) ? 0 : idx;
                this.loadScene(safeIdx);
            }
        };

        // =========================================
        // LAYOUT (PANEL COLLAPSE)
        // =========================================
        const LAYOUT = {
            apply() {
                const body = document.body;
                body.classList.toggle('sidebar-collapsed', !!STATE.sidebarCollapsed);
                body.classList.toggle('inspector-collapsed', !!STATE.inspectorCollapsed);
                body.classList.toggle('console-collapsed', !!STATE.consoleCollapsed);
            },

            toggleSidebar() {
                STATE.sidebarCollapsed = !STATE.sidebarCollapsed;
                this.apply();
                PERSISTENCE.save();
                FEEDBACK.soft();
            },

            toggleInspector() {
                STATE.inspectorCollapsed = !STATE.inspectorCollapsed;
                this.apply();
                PERSISTENCE.save();
                FEEDBACK.soft();
            },

            toggleConsole() {
                STATE.consoleCollapsed = !STATE.consoleCollapsed;
                this.apply();
                PERSISTENCE.save();
                FEEDBACK.soft();
            }
        };

        // =========================================
        // INIT
        // =========================================
        function init() {
            PERSISTENCE.load();
            THEME.set(STATE.theme);
            SIDEBAR.renderTools();
            RENDERER.grid();
            RENDERER.nodes();
            RENDERER.connections();
            RENDERER.initEventListeners();
            LAYOUT.apply();

            // Event listeners
            document.addEventListener('mousemove', EVENTS.handleDragMove);
            document.addEventListener('mouseup', EVENTS.handleDragEnd);
            document.addEventListener('touchmove', EVENTS.handleDragMove, { passive: false });
            document.addEventListener('touchend', EVENTS.handleDragEnd);

            // Navigation buttons
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.addEventListener('click', () => VIEW_MODE.switch(tab.dataset.view));
            });

            // Theme buttons
            document.querySelectorAll('.theme-btn').forEach(btn => {
                btn.addEventListener('click', () => THEME.set(btn.dataset.theme));
            });

            // Enter key handler
            document.getElementById('narrative-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') COMPILER.commit();
            });

            // Scene picker / Sync wiring
            const picker = document.getElementById('scene-picker');
            const syncBtn = document.getElementById('scene-export');
            if (syncBtn) {
                syncBtn.addEventListener('click', () => SCENE_IO.syncFromPicker());
            }
            if (picker) {
                // Listen for export requests from parent AND import data
                window.addEventListener('message', (e) => {
                    if (e.data) {
                        if (e.data.type === 'REQUEST_EXPORT') {
                            exportONYX();
                        } else if (e.data.type === 'IMPORT_GAR') {
                            importGAR(e.data.data);
                        }
                    }
                });

                // Try to hydrate from Merge SceneCollection
                SCENE_IO.loadFromLocalStorage();

                LOG.success('TAO System initialized');
                LOG.info('Ready for narrative construction');
            }
        }

        function importGAR(data) {
            LOG.info('Received GAR data...');

            const garData = data.channels ? data.channels[0] : data;

            if (!garData) {
                LOG.error('Invalid GAR data received');
                return;
            }

            // Helper: Map RGB to TAO Type (VERY Sensitive)
            function getTypeFromColor(r, g, b, edge = 0) {
                const brightness = (r + g + b) / 3;
                const maxChan = Math.max(r, g, b);
                const minChan = Math.min(r, g, b);
                const saturation = maxChan - minChan;

                // High Edge = Obstacle
                if (edge > 0.5) return 'Obstacle';

                // Core (Yellow)
                if (r > 150 && g > 150 && b < 120 && saturation > 30) return 'Core';

                // Relaxed color biases
                if (r > g + 15 && r > b + 15) return 'Obstacle';
                if (g > r + 15 && g > b + 15) return 'Goal';
                if (b > r + 15 && b > g + 15) return 'Entity';

                // Brightness fallback
                if (brightness > 200) return 'Location';
                if (brightness > 150) return 'Core';
                if (brightness < 80) return 'Obstacle';

                // Grayscale with edge
                if (saturation < 20) {
                    if (edge > 0.3) return 'Obstacle';
                    return 'Goal';
                }

                return 'Entity';
            }

            // 1. Handle Rich Cell Data (New Format)
            if (garData.cells) {
                LOG.success(`Importing Rich Data: ${garData.name}`);

                const nodes = [];
                const links = [];
                const createdIds = new Map();
                const occupiedCells = new Set();

                // TAO now uses 20x20 grid to match GAR perfectly!
                const GRID_SIZE = 20;
                const garCols = garData.meta.cols || 20;
                const garRows = garData.meta.rows || 20;

                console.log(`[TAO] Using ${GRID_SIZE}x${GRID_SIZE} grid (1:1 mapping with GAR)`);

                // Helper: check if grid cell is occupied
                function isCellOccupied(gridX, gridY) {
                    return occupiedCells.has(`${gridX},${gridY}`);
                }

                // Helper: mark cell as occupied
                function occupyCell(gridX, gridY, id) {
                    occupiedCells.add(`${gridX},${gridY}`);
                    createdIds.set(`${gridX},${gridY}`, id);
                }

                // Sort cells by importance (edge density, then brightness)
                const sortedCells = garData.cells
                    .map((cell, idx) => ({ ...cell, idx }))
                    .sort((a, b) => {
                        const edgeDiff = (b.edge || 0) - (a.edge || 0);
                        if (Math.abs(edgeDiff) > 0.1) return edgeDiff;
                        const brightA = (a.color.r + a.color.g + a.color.b) / 3;
                        const brightB = (b.color.r + b.color.g + b.color.b) / 3;
                        return brightB - brightA;
                    });

                sortedCells.forEach(cell => {
                    // Use GAR coordinates directly (perfect 1:1 mapping!)
                    const gridX = cell.x;
                    const gridY = cell.y;

                    // Skip if already occupied
                    if (isCellOccupied(gridX, gridY)) {
                        return;
                    }

                    // Convert to percentage (0-100)
                    const targetX = (gridX / (GRID_SIZE - 1)) * 100;
                    const targetY = (gridY / (GRID_SIZE - 1)) * 100;

                    const id = Date.now() + Math.random();
                    const type = getTypeFromColor(cell.color.r, cell.color.g, cell.color.b, cell.edge || 0);

                    const node = {
                        id,
                        type: type.toLowerCase(),
                        icon: type,
                        label: `${type} ${gridX},${gridY}`,
                        x: targetX,
                        y: targetY,
                        data: { color: cell.color, flow: cell.flow, edge: cell.edge, gridX, gridY }
                    };

                    nodes.push(node);
                    occupyCell(gridX, gridY, id);
                });
                // Create narrative structure links
                // Connect entities based on semantic relationships:
                // - Entities can desire Goals
                // - Obstacles conflict with Goals
                // - Core connects to everything nearby
                nodes.forEach(node => {
                    const gridX = node.data.gridX;
                    const gridY = node.data.gridY;

                    // Find nearby nodes (within 2 grid cells)
                    nodes.forEach(otherNode => {
                        if (node.id === otherNode.id) return;

                        const dx = Math.abs(gridX - otherNode.data.gridX);
                        const dy = Math.abs(gridY - otherNode.data.gridY);
                        const dist = dx + dy; // Manhattan distance

                        if (dist <= 2) {
                            let linkType = null;

                            // Entity ‚Üí Goal = desire
                            if (node.type === 'entity' && otherNode.type === 'goal') {
                                linkType = 'desire';
                            }
                            // Obstacle ‚Üí Goal/Entity = conflict
                            else if (node.type === 'obstacle' && (otherNode.type === 'goal' || otherNode.type === 'entity')) {
                                linkType = 'conflict';
                            }
                            // Core ‚Üí anything = morphism (transformation)
                            else if (node.type === 'core' || otherNode.type === 'core') {
                                linkType = 'morphism';
                            }
                            // Goal ‚Üí Goal = flow (sequence)
                            else if (node.type === 'goal' && otherNode.type === 'goal') {
                                linkType = 'flow';
                            }

                            if (linkType) {
                                links.push({
                                    from: node.id,
                                    to: otherNode.id,
                                    type: linkType
                                });
                            }
                        }
                    });
                });

                // Add all nodes to state
                STATE.nodes.push(...nodes);
                STATE.links.push(...links);

                // Add background image to grid-shell
                if (garData.meta?.backgroundImage) {
                    console.log('[TAO] Background image data received:',
                        garData.meta.backgroundImage.substring(0, 50) + '...',
                        'Length:', garData.meta.backgroundImage.length);

                    const gridShell = document.getElementById('grid-shell');
                    let bgImg = document.getElementById('gar-background-img');
                    if (!bgImg) {
                        bgImg = document.createElement('img');
                        bgImg.id = 'gar-background-img';
                        bgImg.style.cssText = 'position:absolute; inset:0; width:100%; height:100%; object-fit:contain; opacity:0.3; pointer-events:none; z-index:1;';
                        gridShell.insertBefore(bgImg, gridShell.firstChild);
                        console.log('[TAO] Created background image element');
                    }
                    bgImg.onload = () => {
                        console.log('[TAO] Background image loaded successfully:', bgImg.naturalWidth, 'x', bgImg.naturalHeight);
                    };
                    bgImg.onerror = (e) => {
                        console.error('[TAO] Failed to load background image:', e);
                    };
                    bgImg.src = garData.meta.backgroundImage;
                } else {
                    console.warn('[TAO] No background image in GAR data');
                }

                RENDERER.nodes();
                RENDERER.connections();
                LOG.success(`Imported ${garData.cells.length} semantic entities`);
                PERSISTENCE.save();
                return;
            }

            // 2. Handle Legacy Grid Format (gar-onyx-bridge)
            if (garData.grid) {
                LOG.success(`Importing Grid: ${garData.name || 'GAR Scene'}`);
                let count = 0;
                garData.grid.forEach((row, y) => {
                    row.forEach((cell, x) => {
                        if (cell && cell.type) {
                            const step = 100 / 9;
                            const id = Date.now() + Math.random();
                            STATE.nodes.push({
                                id,
                                type: cell.type.toLowerCase(),
                                icon: cell.type,
                                label: cell.label || cell.type,
                                x: (x + 0.5) * step,
                                y: (y + 0.5) * step
                            });
                            count++;
                        }
                    });
                });
                RENDERER.nodes();
                RENDERER.connections();
                LOG.success(`Imported ${count} entities from GAR`);
                PERSISTENCE.save();
            } else {
                LOG.warn('Unknown GAR data format');
            }
        }

        // Fix Persistence Quota Error
        PERSISTENCE.save = function () {
            try {
                const data = {
                    nodes: STATE.nodes,
                    links: STATE.links,
                    viewMode: STATE.viewMode,
                    theme: STATE.theme,
                    sidebarCollapsed: STATE.sidebarCollapsed,
                    inspectorCollapsed: STATE.inspectorCollapsed,
                    consoleCollapsed: STATE.consoleCollapsed
                };
                localStorage.setItem('onyx_storytelling_state', JSON.stringify(data));
            } catch (e) {
                console.warn('Storage quota exceeded, could not save state locally.');
                LOG.warn('Storage full - state not saved to disk');
            }
        };

        function exportONYX() {
            // Construct ONYX channel from current state
            const channel = {
                id: `tao-${Date.now()}`,
                name: 'TAO Graph Export',
                type: 'narrative-graph',
                nodes: STATE.nodes,
                links: STATE.links,
                meta: {
                    exportedAt: new Date().toISOString(),
                    viewMode: STATE.viewMode,
                    theme: STATE.theme
                }
            };

            // Post to parent (Studio)
            window.parent.postMessage({ type: 'GAR_EXPORT', data: channel }, '*');
            LOG.success('Exported graph to ONYX Studio');
        }

        // Expose for external calls
        window.exportONYX = exportONYX;

        // Start
        init();
    </script>
</body>

</html>