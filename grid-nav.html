<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emoji Multiverse Navigator üó∫Ô∏è</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the smooth zoom animation and mobile touch targets */
        :root {
            --grid-transition-duration: 400ms;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc;
        }

        .emoji-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            /* Large touch target for mobile */
            cursor: pointer;
            user-select: none;
            transition: background-color 0.1s ease, transform 0.1s ease;
            touch-action: manipulation;
            /* Prevents unwanted browser actions on tap */
            border: 1px solid #e0e7ff;
            /* subtle border */
        }

        .emoji-cell:active {
            transform: scale(0.95);
            /* Feedback on tap */
            background-color: #eef2ff;
        }

        /* Animation Classes */
        .zoom-out {
            transform: scale(0.5);
            opacity: 0;
            transition: transform var(--grid-transition-duration) ease-in, opacity var(--grid-transition-duration) ease-in;
        }

        .zoom-in {
            transform: scale(1.0);
            opacity: 1.0;
            transition: transform var(--grid-transition-duration) ease-out, opacity var(--grid-transition-duration) ease-out;
        }

        /* Styling for the always-visible location marker */
        #location-marker {
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Ensure the grid container takes available space */
        #grid-container {
            flex-grow: 1;
        }

        /* Minimap styles */
        #minimap {
            padding: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
            /* Allow horizontal scroll for deep paths */
            white-space: nowrap;
        }

        /* Full mobile screen height */
        .h-screen {
            height: 100vh;
        }
    </style>
</head>

<body class="h-screen flex flex-col">

    <!-- Minimap (Always Visible) üß≠ -->
    <div id="minimap" class="bg-indigo-50/95 text-xl">
        <!-- Content generated by JS -->
    </div>

    <!-- Main Grid Container -->
    <div id="grid-container" class="relative flex items-center justify-center bg-gray-50 p-4">

        <!-- Current Location Marker üìç -->
        <div id="location-marker"
            class="absolute top-4 left-4 z-10 text-5xl transition-all duration-300 opacity-0 bg-white/70 p-1 rounded-lg">
            <!-- Current Location Emoji goes here -->
        </div>

        <!-- The 9x9 Grid itself -->
        <div id="grid"
            class="w-full max-w-lg aspect-square grid grid-cols-9 bg-white shadow-2xl rounded-xl overflow-hidden zoom-in">
            <!-- Cells generated by JS -->
        </div>

        <!-- Back Button (Return to Parent) ‚§¥Ô∏è -->
        <button id="back-button"
            class="absolute bottom-4 right-4 z-20 p-4 bg-red-500/90 hover:bg-red-600 active:bg-red-700 rounded-full shadow-xl text-4xl transition-all duration-200 hidden border-4 border-white"
            onclick="goBack()">
            ‚§¥Ô∏è
        </button>

        <!-- Custom Alert/Feedback Message Box -->
        <div id="message-box"
            class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-green-500 text-white p-4 rounded-xl shadow-2xl text-xl z-50 opacity-0 pointer-events-none transition-opacity duration-500">
            <!-- Message content -->
        </div>
    </div>

    <script>
        const EMOJI_POOL = [
            'üè†', 'üå≥', 'üåä', '‚õ∞Ô∏è', 'üè≠', 'üèüÔ∏è', 'üé†', 'üí°', 'üì°', 'üö¶', 'üöß', '‚õΩ',
            'üö®', '‚öì', 'üö¢', 'üöÄ', 'üõ∏', 'üõ∞Ô∏è', 'üöÅ', 'üöä', 'üöÇ', 'üöÉ', 'üöå', 'üöê',
            'üöó', 'üöï', 'üõª', 'üöö', 'üöú', 'üèçÔ∏è', 'üö≤', 'üõ¥', '‚è±Ô∏è', 'üóìÔ∏è', 'üìè', 'üìê',
            '‚úÇÔ∏è', 'üñäÔ∏è', 'üñçÔ∏è', 'üì∞', 'üìö', 'üìì', '‚úèÔ∏è', 'üìé', 'üîó', 'üî¨', 'üî≠', 'üß™',
            'üß¨', 'ü¶†', 'üå°Ô∏è', 'üíâ', 'üíä', 'ü©π', 'ü©∫', 'üóùÔ∏è', 'üíé', 'üëë', 'üí∞', 'üîë',
            'üî®', 'üõ†Ô∏è', 'ü™ö', 'ü™õ', 'üîó', '‚öôÔ∏è', 'üî©', 'üß±', 'üö™', 'ü™ü', 'ü™ë', 'üõãÔ∏è', 'üõèÔ∏è'
        ];

        const GRID_SIZE = 9;
        const CELL_COUNT = GRID_SIZE * GRID_SIZE;

        let history = []; // Stores the path of parent emojis
        let currentGridData = []; // Stores the current 9x9 grid's data

        const gridElement = document.getElementById('grid');
        const minimapElement = document.getElementById('minimap');
        const locationMarker = document.getElementById('location-marker');
        const backButton = document.getElementById('back-button');
        const messageBox = document.getElementById('message-box');

        /**
         * Utility function to display a temporary emoji message.
         * @param {string} emoji The emoji to display.
         */
        function showMessage(emoji) {
            messageBox.innerHTML = emoji;
            messageBox.classList.remove('opacity-0');
            messageBox.classList.add('opacity-100');
            setTimeout(() => {
                messageBox.classList.remove('opacity-100');
                messageBox.classList.add('opacity-0');
            }, 1000);
        }

        /**
         * Generates a new 9x9 grid of random emojis.
         * @returns {Array<string>} A 81-element array of emojis.
         */
        function generateGrid() {
            const grid = [];
            for (let i = 0; i < CELL_COUNT; i++) {
                const randomIndex = Math.floor(Math.random() * EMOJI_POOL.length);
                grid.push(EMOJI_POOL[randomIndex]);
            }
            return grid;
        }

        /**
         * Renders the current grid data into the DOM.
         */
        function renderGrid() {
            gridElement.innerHTML = ''; // Clear previous grid

            currentGridData.forEach((emoji, index) => {
                const cell = document.createElement('div');
                cell.className = 'emoji-cell';
                cell.textContent = emoji;
                cell.dataset.index = index;
                cell.addEventListener('click', () => handleCellClick(emoji));
                gridElement.appendChild(cell);
            });

            updateMinimap();
            updateLocationMarker();
            updateBackButton();
        }

        /**
         * Renders the current path/history in the minimap.
         */
        function updateMinimap() {
            minimapElement.innerHTML = '';

            if (history.length === 0) {
                // Root level
                minimapElement.innerHTML = `<span class="text-indigo-700 font-bold">üåç ROOT LEVEL üìç</span>`;
                return;
            }

            const pathHtml = history.map((emoji, index) => {
                const isCurrent = index === history.length - 1;
                const pathSeparator = index < history.length - 1 ? ' ‚û°Ô∏è ' : '';

                // Highlight the current position
                const classes = isCurrent ? 'text-indigo-700 font-bold text-2xl' : 'text-gray-500 text-lg';

                return `<span class="${classes}">${emoji}</span>${pathSeparator}`;
            }).join('');

            minimapElement.innerHTML = `<span class="text-xl">üß≠ PATH: </span>` + pathHtml;
            // Scroll to the end of the minimap to show current location
            minimapElement.scrollLeft = minimapElement.scrollWidth;
        }

        /**
         * Updates the persistent location marker.
         */
        function updateLocationMarker() {
            if (history.length > 0) {
                // The last element added to history is the parent of the *current* grid.
                locationMarker.textContent = history[history.length - 1];
                locationMarker.classList.remove('opacity-0');
            } else {
                locationMarker.classList.add('opacity-0');
                locationMarker.textContent = '';
            }
        }

        /**
         * Toggles the visibility of the back button.
         */
        function updateBackButton() {
            if (history.length > 0) {
                backButton.classList.remove('hidden');
            } else {
                backButton.classList.add('hidden');
            }
        }

        /**
         * Handles the click on a grid cell to dive deeper.
         * @param {string} clickedEmoji The emoji of the cell that was clicked.
         */
        function handleCellClick(clickedEmoji) {
            // 1. Zoom Out Animation Start (Scale down the old grid)
            gridElement.classList.add('zoom-out');
            showMessage(clickedEmoji);

            // 2. Data Update after a short delay to allow visual transition start
            setTimeout(() => {
                history.push(clickedEmoji);
                currentGridData = generateGrid();

                // 3. Render New Content (content is invisible due to zoom-out class)
                renderGrid();

                // 4. Zoom In Animation Start (Scale up the new grid)
                gridElement.classList.remove('zoom-out');
                gridElement.classList.add('zoom-in');

                // 5. Clean up animation class
                setTimeout(() => {
                    gridElement.classList.remove('zoom-in');
                }, 400); // Must match the CSS transition duration
            }, 200); // Short delay for visual effect
        }

        /**
         * Handles the back button click to return to the parent grid.
         */
        function goBack() {
            if (history.length === 0) {
                return; // Already at root
            }

            // 1. Zoom Out Animation Start
            gridElement.classList.add('zoom-out');

            const lastEmoji = history.pop(); // Remove current location
            showMessage(`‚§¥Ô∏è ${lastEmoji}`);

            // 2. Data Update after delay
            setTimeout(() => {
                // To simulate going back, we regenerate a grid (as we don't store previous grid states)
                // For a true hierarchical map, the previous grid data would be stored and retrieved here.
                currentGridData = generateGrid();

                // 3. Render New Content
                renderGrid();

                // 4. Zoom In Animation Start
                gridElement.classList.remove('zoom-out');
                gridElement.classList.add('zoom-in');

                // 5. Clean up animation class
                setTimeout(() => {
                    gridElement.classList.remove('zoom-in');
                }, 400); // Must match the CSS transition duration
            }, 200);
        }

        // Initialize the application on load
        window.onload = function () {
            currentGridData = generateGrid();
            renderGrid();
        };

        // Expose goBack to the button's inline click handler
        window.goBack = goBack;

    </script>
</body>

</html>