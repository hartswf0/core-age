<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
    <title>Grid Assembles Reality ‚Äî 20√ó20 Mosaic</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üê∏</text></svg>">
    <style>
        :root {
            --img: url('tutorial_assets/images/city_final.png');
            --cols: 20;
            --rows: 20;
            --size: min(92vmin, 1024px);
            --grid: rgba(0, 255, 180, .28);
            --bg: #0b0d10;
            --ink: #e9e9e9;
            --accent: #ffcc00;
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--ink);
            font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif
        }

        .main {
            min-height: 100%;
            display: grid;
            place-items: center;
            padding: 20px
        }

        .panel {
            width: var(--size)
        }

        .hdr {
            display: flex;
            align-items: center;
            gap: .75rem;
            margin-bottom: 12px
        }

        .hdr h1 {
            font-weight: 700;
            letter-spacing: .02em;
            font-size: clamp(16px, 2.6vmin, 24px);
            margin: 0
        }

        .hdr .small {
            opacity: .7;
            font-size: .9em
        }

        .controls {
            margin-left: auto;
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        button,
        input,
        select {
            background: #12161c;
            color: var(--ink);
            border: 1px solid #2a323a;
            border-radius: 10px;
            padding: 8px 10px
        }

        button {
            cursor: pointer
        }

        button:hover {
            border-color: #3a9
        }

        input.url {
            min-width: 220px;
            width: min(40vw, 460px)
        }

        label.chk {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border: 1px solid #2a323a;
            border-radius: 10px
        }

        label.range {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            border: 1px solid #2a323a;
            border-radius: 10px
        }

        input[type="range"] {
            accent-color: #ffd24a
        }

        .stage {
            position: relative;
            width: var(--size);
            height: var(--size);
            border-radius: 18px;
            overflow: hidden;
            box-shadow: 0 10px 45px rgba(0, 0, 0, .5), inset 0 0 0 1px #222
        }

        .stage::after {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(60% 60% at 50% 45%, transparent 0 60%, rgba(0, 0, 0, .35) 100%);
            pointer-events: none
        }

        .grid {
            position: absolute;
            inset: 0;
            display: grid;
            grid-template-columns: repeat(var(--cols), 1fr);
            grid-template-rows: repeat(var(--rows), 1fr)
        }

        .tile {
            position: relative;
            opacity: 0;
            transform: scale(.96);
            filter: blur(8px) saturate(.1) brightness(.7);
            transition: opacity .6s cubic-bezier(.18, .7, .16, 1), transform .6s cubic-bezier(.18, .7, .16, 1), filter .9s ease;
            background-image: var(--img);
            background-repeat: no-repeat;
            background-size: calc(var(--cols)*100%) calc(var(--rows)*100%);
            outline: 1px solid color-mix(in hsl, var(--grid) 95%, transparent)
        }

        .tile.on {
            opacity: 1;
            transform: scale(1);
            filter: blur(0) saturate(1) brightness(1);
            outline-color: color-mix(in hsl, var(--grid) 0%, transparent)
        }

        @keyframes shimmer {
            0% {
                transform: translateY(0)
            }

            50% {
                transform: translateY(-.7px)
            }

            100% {
                transform: translateY(0)
            }
        }

        .stage.building {
            filter: contrast(1.02) saturate(1.03)
        }

        .tile.on.build-wobble {
            animation: shimmer 1.6s ease-in-out var(--delay) 2
        }

        .flicker {
            pointer-events: none;
            position: absolute;
            inset: 0;
            background: radial-gradient(100% 65% at 50% 70%, rgba(255, 110, 30, .18), transparent 60%);
            mix-blend-mode: screen;
            opacity: .0;
            transition: opacity .6s ease
        }

        .stage.ready .flicker {
            opacity: .6
        }

        .legend {
            margin-top: 10px;
            color: #9aa3ad;
            font-size: .92em
        }

        .code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace
        }

        .badge {
            background: #11161c;
            border: 1px solid #2a323a;
            padding: 4px 8px;
            border-radius: 8px;
            margin-right: 6px
        }

        .controls label.seg {
            display: inline-flex;
            align-items: center;
            gap: 6px
        }

        /* Segmentation overlay */
        .segOverlay {
            position: absolute;
            inset: 0;
            pointer-events: none
        }

        .segOverlay .cell {
            opacity: 0;
            transition: opacity .6s ease
        }

        .segOverlay.show .cell {
            opacity: var(--overlay-alpha, .22)
        }

        .segOverlay .bound {
            stroke-width: 3;
            stroke-linecap: round;
            opacity: .95
        }

        .segOverlay .bound.voronoi {
            stroke-dasharray: 8 8;
            opacity: .85
        }

        .segOverlay text {
            font: 600 13px/1 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
            fill: #fff;
            paint-order: stroke;
            stroke: #000;
            stroke-width: 3px
        }

        .legend .swatch {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 3px;
            margin-right: 6px;
            vertical-align: -2px
        }

        .tests {
            margin-top: 10px;
            background: #0e131a;
            border: 1px solid #2a323a;
            border-radius: 10px;
            padding: 8px 10px;
            color: #b7c2cc
        }

        .tests summary {
            cursor: pointer
        }

        .tests .pass {
            color: #63e6be
        }

        .tests .fail {
            color: #ff6b6b
        }

        /* Legend for segments */
        .seg-legend {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px
        }

        .seg-legend .item {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #0e131a;
            border: 1px solid #2a323a;
            padding: 4px 8px;
            border-radius: 8px
        }
    </style>
</head>

<body>
    <div class="main">
        <div class="panel">
            <div class="hdr">
                <h1>Grid Assembles Reality</h1>
                <div class="small">20√ó20 cells, ripple/edge/segment assembly</div>
                <div class="controls">
                    <input class="url" placeholder="Paste image URL (optional)" />
                    <select id="mode" title="Assembly mode">
                        <option value="ripple">Ripple</option>
                        <option value="edges">Edges‚Äëfirst</option>
                        <option value="contour" selected>Contour BFS</option>
                        <option value="segments">Segments (K‚Äëmeans)</option>
                    </select>
                    <label class="seg" title="# of segments for K‚Äëmeans">k <input id="k" type="number" min="2" max="8"
                            value="4" /></label>
                    <label class="chk"><input type="checkbox" id="chkLabels" checked /> Labels</label>
                    <label class="chk"><input type="checkbox" id="chkBounds" checked /> Boundaries</label>
                    <label class="chk"><input type="checkbox" id="chkVoronoi" checked /> Voronoi</label>
                    <label class="range">Œ± <input type="range" id="alpha" min="0" max="100" value="22" /></label>
                    <button id="rebuild">Reassemble</button>
                    <button id="exportONYX" title="Export to ONYX narrative format"
                        style="background: #3a9; border-color: #3a9;">Export to ONYX</button>
                    <button id="annotate">Annotate</button>
                    <button id="exportONYX" title="Export to ONYX narrative format"
                        style="background: #3a9; border-color: #3a9;">Export to ONYX</button>
                    <button id="exportAnn" title="Export base image + annotations">Export PNG</button>
                    <button id="exportONYX" title="Export to ONYX narrative format"
                        style="background: #3a9; border-color: #3a9;">Export to ONYX</button>
                    <button id="exportOverlay" title="Export only the overlay">Export Overlay</button>
                    <button id="exportONYX" title="Export to ONYX narrative format"
                        style="background: #3a9; border-color: #3a9;">Export to ONYX</button>
                </div>
            </div>

            <div class="stage" id="stage">
                <div class="grid" id="grid"></div>
                <svg class="segOverlay" id="segSvg" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"></svg>
                <div class="flicker"></div>
            </div>

            <div class="legend code">
                <span class="badge">Prompt (‚âà250c)</span>Embers of Ancestry‚Äîwarm dusk campfire cover. Title fades in;
                embers flicker/spark; frog breathes + rare blink; smoke drifts; logs parallax; soft bokeh float; ‚ÄúCOOL
                RADIO‚Äù slides in; vignette breathes. Cinematic, gentle loop; heat‚Äëshimmer, no hard cuts.
            </div>

            <div class="seg-legend code" id="segLegend"></div>

            <details class="tests" open>
                <summary>Self‚Äëtests</summary>
                <ul id="test-list" class="code" style="padding-left:18px;margin:6px 0 0"></ul>
            </details>
        </div>
    </div>

    <script>
        /********************
         * DOM & CONFIG
         ********************/
        const STAGE = document.getElementById('stage');
        const GRID = document.getElementById('grid');
        const segSvg = document.getElementById('segSvg');
        const rebuildBtn = document.getElementById('rebuild');
        const annotateBtn = document.getElementById('annotate');
        const exportAnnBtn = document.getElementById('exportAnn');
        const exportOverlayBtn = document.getElementById('exportOverlay');
        const urlInput = document.querySelector('.url');
        const modeSelect = document.getElementById('mode');
        const kInput = document.getElementById('k');
        const alphaInput = document.getElementById('alpha');
        const chkLabels = document.getElementById('chkLabels');
        const chkBounds = document.getElementById('chkBounds');
        const chkVoronoi = document.getElementById('chkVoronoi');
        const SEG_LEGEND = document.getElementById('segLegend');
        const TEST_LIST = document.getElementById('test-list');

        const COLS = 20, ROWS = 20;                  // grid
        let ORIGIN = { c: 8, r: 13 };                // default seed (frog-ish)
        const CELL_DELAY = 90;                       // ms per ring (fallback)
        const NOISE = 80;                            // random jitter per cell
        const WOBBLE_PROB = 0.55;                    // some tiles shimmer briefly

        let LAST_LABELS = null, LAST_K = null, LAST_CENTROIDS = null, LAST_AREAS = null;

        /********************
         * UTIL
         ********************/
        function getCurrentImgURL() {
            const s = getComputedStyle(document.documentElement).getPropertyValue('--img');
            const m = s.match(/url\(["']?(.*?)["']?\)/);
            return m ? m[1] : '';
        }
        let IMG_URL = getCurrentImgURL();

        // Offscreen analysis canvas
        const CANVAS = document.createElement('canvas');
        const CTX = CANVAS.getContext('2d', { willReadFrequently: true });
        CANVAS.width = COLS * 16; CANVAS.height = ROWS * 16; // analysis resolution

        function setImage(url) {
            if (url) {
                IMG_URL = url;
                document.documentElement.style.setProperty('--img', `url('${url}')`);
            }
        }

        function makeGrid() {
            GRID.style.setProperty('--cols', COLS);
            GRID.style.setProperty('--rows', ROWS);
            GRID.innerHTML = '';
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const t = document.createElement('div');
                    t.className = 'tile';
                    const x = (c / (COLS - 1)) * 100, y = (r / (ROWS - 1)) * 100; // slice position
                    t.style.backgroundPosition = `${x}% ${y}%`;
                    GRID.appendChild(t);
                }
            }
        }

        function coverDraw(img, ctx, W, H) {
            const ar = img.width / img.height, stageAR = W / H;
            let dw = W, dh = H, dx = 0, dy = 0;
            if (ar > stageAR) { dh = H; dw = dh * ar; dx = -(dw - W) / 2; }
            else { dw = W; dh = dw / ar; dy = -(dh - H) / 2; }
            ctx.clearRect(0, 0, W, H);
            ctx.drawImage(img, dx, dy, dw, dh);
        }

        function loadToCanvas(url) {
            return new Promise(resolve => {
                const im = new Image();
                im.crossOrigin = 'anonymous';
                im.onload = () => { coverDraw(im, CTX, CANVAS.width, CANVAS.height); resolve({ ok: true, img: im }); };
                im.onerror = () => {
                    // Fallback for CORS/file:// 
                    CTX.fillStyle = '#1e293b';
                    CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);
                    for (let i = 0; i < 30; i++) {
                        CTX.fillStyle = `hsl(${Math.random() * 360}, 60%, 50%)`;
                        CTX.fillRect(Math.random() * CANVAS.width, Math.random() * CANVAS.height, 40, 40);
                    }
                    resolve({ ok: true, placeholder: true });
                };
                im.src = url;
            });
        }

        /********************
         * ANALYSIS (edges + features)
         ********************/
        function computeFeatures() {
            try {
                const w = CANVAS.width, h = CANVAS.height;
                const { data } = CTX.getImageData(0, 0, w, h);
                const gray = new Float32Array(w * h);
                for (let p = 0, i = 0; i < data.length; i += 4, p++) {
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    gray[p] = 0.299 * r + 0.587 * g + 0.114 * b;
                }
                const grad = new Float32Array(w * h);
                for (let y = 1; y < h - 1; y++) {
                    for (let x = 1; x < w - 1; x++) {
                        const p = y * w + x;
                        const gx = -gray[p - w - 1] + gray[p - w + 1] - 2 * gray[p - 1] + 2 * gray[p + 1] - gray[p + w - 1] + gray[p + w + 1];
                        const gy = gray[p - w - 1] + 2 * gray[p - w] + gray[p - w + 1] - gray[p + w - 1] - 2 * gray[p + w] - gray[p + w + 1];
                        grad[p] = Math.hypot(gx, gy);
                    }
                }
                const tw = Math.floor(w / COLS), th = Math.floor(h / ROWS);
                const edges = [], colors = []; let maxE = 1e-6;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        let sumE = 0, sumR = 0, sumG = 0, sumB = 0, count = 0;
                        for (let yy = r * th; yy < (r + 1) * th; yy++) {
                            for (let xx = c * tw; xx < (c + 1) * tw; xx++) {
                                const p = yy * w + xx; const di = p * 4;
                                sumE += grad[p];
                                sumR += data[di]; sumG += data[di + 1]; sumB += data[di + 2];
                                count++;
                            }
                        }
                        const e = sumE / count; maxE = Math.max(maxE, e);
                        edges.push(e); colors.push([sumR / count, sumG / count, sumB / count]);
                    }
                }
                const normEdges = edges.map(e => e / maxE);
                return { ok: true, edges: normEdges, colors };
            } catch (err) { console.warn('Feature compute failed (tainted image?)', err); return { ok: false } }
        }

        /********************
         * CLUSTERING + OVERLAY
         ********************/
        function kmeans(points, k = 4, iters = 8) {
            const n = points.length, dim = points[0].length;
            const centers = Array.from({ length: k }, _ => points[Math.floor(Math.random() * n)].slice());
            const labels = new Array(n).fill(0);
            for (let it = 0; it < iters; it++) {
                for (let i = 0; i < n; i++) {
                    let best = 0, bestd = Infinity; const p = points[i];
                    for (let j = 0; j < k; j++) {
                        let d = 0; const c = centers[j];
                        for (let dI = 0; dI < dim; dI++) { const diff = p[dI] - c[dI]; d += diff * diff; }
                        if (d < bestd) { bestd = d; best = j; }
                    }
                    labels[i] = best;
                }
                const sums = Array.from({ length: k }, _ => new Array(dim).fill(0));
                const counts = new Array(k).fill(0);
                for (let i = 0; i < n; i++) { const l = labels[i]; counts[l]++; const p = points[i]; for (let dI = 0; dI < dim; dI++) sums[l][dI] += p[dI]; }
                for (let j = 0; j < k; j++) { if (counts[j]) for (let dI = 0; dI < dim; dI++) centers[j][dI] = sums[j][dI] / counts[j]; }
            }
            return labels;
        }

        function goldenColor(i, a = 0.9) { const h = (i * 137.508) % 360; return `hsla(${h} 85% 55% / ${a})`; }

        function computeCentroidsAndAreas(labels, k) {
            const cent = Array.from({ length: k }, () => ({ x: 0, y: 0, n: 0 }));
            const areas = new Array(k).fill(0);
            for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
                const id = r * COLS + c, cl = labels[id];
                cent[cl].x += c + 0.5; cent[cl].y += r + 0.5; cent[cl].n++;
                areas[cl]++;
            }
            for (const c of cent) { if (c.n) { c.x /= c.n; c.y /= c.n; } }
            return { cent, areas };
        }

        function renderSegOverlay(labels, k) {
            const W = STAGE.clientWidth, H = STAGE.clientHeight; // use stage size
            segSvg.setAttribute('width', W); segSvg.setAttribute('height', H);
            segSvg.setAttribute('viewBox', `0 0 ${W} ${H}`);
            segSvg.innerHTML = '';
            const gCells = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const gBounds = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const gVor = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const gLabels = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            gBounds.setAttribute('fill', 'none'); gVor.setAttribute('fill', 'none');

            const cw = W / COLS, ch = H / ROWS;
            // centroids/areas
            const { cent, areas } = computeCentroidsAndAreas(labels, k);
            LAST_CENTROIDS = cent; LAST_AREAS = areas;

            // nearest centroid (Voronoi-like on grid)
            const vor = new Array(ROWS * COLS).fill(0);
            for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
                let best = 0, bestd = Infinity;
                for (let j = 0; j < k; j++) {
                    const dx = (c + 0.5) - cent[j].x, dy = (r + 0.5) - cent[j].y; const d = dx * dx + dy * dy; if (d < bestd) { bestd = d; best = j; }
                }
                vor[r * COLS + c] = best;
            }

            // set overlay alpha from UI
            const overlayAlpha = Math.max(0, Math.min(1, parseInt(alphaInput.value) / 100));
            segSvg.style.setProperty('--overlay-alpha', overlayAlpha);

            // draw cells
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const id = r * COLS + c; const cl = labels[id];
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', (c * cw).toFixed(2));
                    rect.setAttribute('y', (r * ch).toFixed(2));
                    rect.setAttribute('width', Math.ceil(cw) + 1);
                    rect.setAttribute('height', Math.ceil(ch) + 1);
                    rect.setAttribute('fill', goldenColor(cl, overlayAlpha));
                    rect.setAttribute('class', 'cell');
                    gCells.appendChild(rect);
                }
            }

            function jitter(n, amp) { return n + (Math.random() * 2 - 1) * amp; }

            // cluster boundaries (solid)
            if (chkBounds.checked) {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 1; c < COLS; c++) {
                        const aL = labels[r * COLS + c - 1], bL = labels[r * COLS + c];
                        if (aL !== bL) {
                            const x = c * cw; let d = ""; const steps = 8, y0 = r * ch, y1 = (r + 1) * ch;
                            for (let i = 0; i <= steps; i++) { const t = i / steps; const y = jitter(y0 + t * (y1 - y0), 1.4); d += (i ? " L " : "M ") + jitter(x, 1.2).toFixed(2) + " " + y.toFixed(2); }
                            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path'); path.setAttribute('d', d); path.setAttribute('stroke', '#fff'); path.setAttribute('class', 'bound'); gBounds.appendChild(path);
                        }
                    }
                }
                for (let c = 0; c < COLS; c++) {
                    for (let r = 1; r < ROWS; r++) {
                        const aT = labels[(r - 1) * COLS + c], bT = labels[r * COLS + c];
                        if (aT !== bT) {
                            const y = r * ch; let d = ""; const steps = 8, x0 = c * cw, x1 = (c + 1) * cw;
                            for (let i = 0; i <= steps; i++) { const t = i / steps; const x = jitter(x0 + t * (x1 - x0), 1.4); d += (i ? " L " : "M ") + x.toFixed(2) + " " + jitter(y, 1.2).toFixed(2); }
                            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path'); path.setAttribute('d', d); path.setAttribute('stroke', '#fff'); path.setAttribute('class', 'bound'); gBounds.appendChild(path);
                        }
                    }
                }
            }

            // voronoi-like boundaries (dashed)
            if (chkVoronoi.checked) {
                const vorColor = '#ffd24a';
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 1; c < COLS; c++) {
                        const aV = vor[r * COLS + c - 1], bV = vor[r * COLS + c];
                        if (aV !== bV) {
                            const x = c * cw; let d = ""; const steps = 8, y0 = r * ch, y1 = (r + 1) * ch;
                            for (let i = 0; i <= steps; i++) { const t = i / steps; const y = jitter(y0 + t * (y1 - y0), 1.6); d += (i ? " L " : "M ") + jitter(x, 1.6).toFixed(2) + " " + y.toFixed(2); }
                            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path'); path.setAttribute('d', d); path.setAttribute('stroke', vorColor); path.setAttribute('class', 'bound voronoi'); gVor.appendChild(path);
                        }
                    }
                }
                for (let c = 0; c < COLS; c++) {
                    for (let r = 1; r < ROWS; r++) {
                        const aV2 = vor[(r - 1) * COLS + c], bV2 = vor[r * COLS + c];
                        if (aV2 !== bV2) {
                            const y = r * ch; let d = ""; const steps = 8, x0 = c * cw, x1 = (c + 1) * cw;
                            for (let i = 0; i <= steps; i++) { const t = i / steps; const x = jitter(x0 + t * (x1 - x0), 1.6); d += (i ? " L " : "M ") + x.toFixed(2) + " " + jitter(y, 1.6).toFixed(2); }
                            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path'); path.setAttribute('d', d); path.setAttribute('stroke', vorColor); path.setAttribute('class', 'bound voronoi'); gVor.appendChild(path);
                        }
                    }
                }
            }

            // labels at centroids
            if (chkLabels.checked) {
                for (let i = 0; i < k; i++) {
                    const cx = cent[i].x * cw, cy = cent[i].y * ch;
                    const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    txt.setAttribute('x', cx.toFixed(1));
                    txt.setAttribute('y', cy.toFixed(1));
                    txt.setAttribute('text-anchor', 'middle');
                    txt.setAttribute('dominant-baseline', 'middle');
                    const pct = ((areas[i] / (ROWS * COLS)) * 100).toFixed(1);
                    txt.textContent = `#${i} ‚Äî ${pct}%`;
                    gLabels.appendChild(txt);
                }
            }

            segSvg.appendChild(gCells); if (chkBounds.checked) segSvg.appendChild(gBounds); if (chkVoronoi.checked) segSvg.appendChild(gVor); if (chkLabels.checked) segSvg.appendChild(gLabels);
            segSvg.classList.add('show');

            // legend UI
            SEG_LEGEND.innerHTML = '';
            for (let i = 0; i < k; i++) {
                const pct = ((areas[i] / (ROWS * COLS)) * 100).toFixed(1);
                const item = document.createElement('div'); item.className = 'item';
                const sw = document.createElement('span'); sw.className = 'swatch'; sw.style.background = goldenColor(i, 1);
                const label = document.createElement('span'); label.textContent = `#${i} ‚Äî ${pct}%`;
                item.appendChild(sw); item.appendChild(label); SEG_LEGEND.appendChild(item);
            }
        }

        /********************
         * SCHEDULING + ASSEMBLY
         ********************/
        function buildSchedule(mode, edges, clusters) {
            const tiles = [...GRID.children];
            const idxs = [...Array(tiles.length).keys()];
            const STEP = 26; // ms
            if (mode === 'edges') {
                idxs.sort((a, b) => edges[b] - edges[a]);
                return idxs.map((id, i) => [id, i * STEP]);
            }
            if (mode === 'contour') {
                const visited = new Array(ROWS * COLS).fill(false); const order = []; const frontier = [];
                function push(r, c) { if (r < 0 || c < 0 || r >= ROWS || c >= COLS) return; const id = r * COLS + c; if (visited[id]) return; frontier.push(id); visited[id] = true; }
                push(ORIGIN.r, ORIGIN.c);
                while (frontier.length) {
                    frontier.sort((a, b) => edges[b] - edges[a]);
                    const id = frontier.shift(); order.push(id);
                    const r = Math.floor(id / COLS), c = id % COLS;
                    push(r - 1, c); push(r + 1, c); push(r, c - 1); push(r, c + 1);
                }
                return order.map((id, i) => [id, i * STEP]);
            }
            if (mode === 'segments' && clusters) {
                const groups = {}; idxs.forEach(id => { const cl = clusters[id]; (groups[cl] || (groups[cl] = [])).push(id); });
                function medianEdge(list) { const s = list.map(i => edges[i]).sort((a, b) => a - b); return s[Math.floor(s.length / 2)] || 0; }
                const clusterOrder = Object.keys(groups).sort((A, B) => medianEdge(groups[B]) - medianEdge(groups[A]));
                const order = [];
                for (const cl of clusterOrder) {
                    const ids = groups[cl];
                    const vis = new Set();
                    const q = [];
                    const start = ORIGIN.r * COLS + ORIGIN.c;
                    q.push(ids.includes(start) ? start : ids[0]); vis.add(q[0]);
                    while (q.length) {
                        q.sort((a, b) => edges[b] - edges[a]);
                        const id = q.shift(); order.push(id);
                        const r = Math.floor(id / COLS), c = id % COLS;
                        const N = [[r - 1, c], [r + 1, c], [r, c - 1], [r, c + 1]];
                        for (const [rr, cc] of N) { const nid = rr * COLS + cc; if (rr >= 0 && cc >= 0 && rr < ROWS && cc < COLS && ids.includes(nid) && !vis.has(nid)) { vis.add(nid); q.push(nid); } }
                    }
                    order.push(-1); // gap
                }
                const schedule = []; let t = 0; for (const id of order) { if (id == -1) { t += 300; continue; } schedule.push([id, t]); t += STEP; } return schedule;
            }
            const schedule = [];
            for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) { const id = r * COLS + c; const ring = Math.abs(c - ORIGIN.c) + Math.abs(r - ORIGIN.r); schedule.push([id, ring * CELL_DELAY + Math.random() * NOISE]); }
            schedule.sort((a, b) => a[1] - b[1]);
            return schedule;
        }

        async function assemble() {
            segSvg.classList.remove('show'); segSvg.innerHTML = ''; SEG_LEGEND.innerHTML = '';
            STAGE.classList.add('building'); STAGE.classList.remove('ready');
            LAST_LABELS = LAST_K = LAST_CENTROIDS = LAST_AREAS = null;
            const tiles = [...GRID.children]; tiles.forEach(t => t.classList.remove('on', 'build-wobble'));

            const loaded = await loadToCanvas(IMG_URL);
            const features = loaded.ok ? computeFeatures() : { ok: false };

            if (features.ok) {
                let best = Math.floor(ROWS / 2) * COLS + Math.floor(COLS / 2), bestScore = -1; const rad = 3;
                for (let rr = ORIGIN.r - rad; rr <= ORIGIN.r + rad; rr++) {
                    for (let cc = ORIGIN.c - rad; cc <= ORIGIN.c + rad; cc++) {
                        if (rr < 0 || cc < 0 || rr >= ROWS || cc >= COLS) continue; const id = rr * COLS + cc; const score = features.edges[id]; if (score > bestScore) { bestScore = score; best = id; }
                    }
                }
                ORIGIN = { r: Math.floor(best / COLS), c: best % COLS };
            }

            let clusters = null; let k = 4;
            if (features.ok) {
                const pts = features.colors.map((rgb, i) => [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, features.edges[i]]);
                k = Math.max(2, Math.min(8, parseInt(kInput.value) || 4));
                clusters = kmeans(pts, k, 8);
                LAST_LABELS = clusters; LAST_K = k;
            }

            const mode = modeSelect.value;
            const schedule = buildSchedule(mode, features.ok ? features.edges : new Array(COLS * ROWS).fill(0), clusters);

            let maxDelay = 0;
            for (const [id, t] of schedule) { if (id < 0) continue; maxDelay = Math.max(maxDelay, t); setTimeout(() => { const tile = tiles[id]; tile.classList.add('on'); if (Math.random() < WOBBLE_PROB) tile.classList.add('build-wobble'); }, t); }
            setTimeout(() => { STAGE.classList.remove('building'); STAGE.classList.add('ready'); if (LAST_LABELS) renderSegOverlay(LAST_LABELS, LAST_K); }, maxDelay + 800);
        }

        /********************
         * EXPORT (PNG)
         ********************/
        async function exportPNG(includeImage = true) {
            const W = STAGE.clientWidth, H = STAGE.clientHeight;
            const canvas = document.createElement('canvas');
            canvas.width = W; canvas.height = H; const ctx = canvas.getContext('2d');

            // draw base image
            let drewImage = false;
            if (includeImage) {
                const load = await new Promise(res => { const im = new Image(); im.crossOrigin = 'anonymous'; im.onload = () => res({ ok: true, im }); im.onerror = () => res({ ok: false }); im.src = IMG_URL; });
                if (load.ok) {
                    const im = load.im; const ar = im.width / im.height, stageAR = W / H; let dw = W, dh = H, dx = 0, dy = 0; if (ar > stageAR) { dh = H; dw = dh * ar; dx = -(dw - W) / 2; } else { dw = W; dh = dw / ar; dy = -(dh - H) / 2; }
                    ctx.drawImage(im, dx, dy, dw, dh); drewImage = true;
                }
            }

            // overlay (cells)
            if (!LAST_LABELS || LAST_K == null) {
                // if no segmentation yet, synthesize a single cluster overlay for export
                LAST_LABELS = new Array(ROWS * COLS).fill(0); LAST_K = 1; const tmp = computeCentroidsAndAreas(LAST_LABELS, LAST_K); LAST_CENTROIDS = tmp.cent; LAST_AREAS = tmp.areas;
            }
            const cw = W / COLS, ch = H / ROWS; const overlayAlpha = Math.max(0, Math.min(1, parseInt(alphaInput.value) / 100));
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const id = r * COLS + c, cl = LAST_LABELS[id]; ctx.fillStyle = goldenColor(cl, overlayAlpha); ctx.fillRect(c * cw, r * ch, Math.ceil(cw) + 1, Math.ceil(ch) + 1);
                }
            }
            // boundaries
            if (chkBounds.checked) {
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.lineCap = 'round';
                function jitter(n, amp) { return n + (Math.random() * 2 - 1) * amp; }
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 1; c < COLS; c++) {
                        const aL = LAST_LABELS[r * COLS + c - 1], bL = LAST_LABELS[r * COLS + c]; if (aL !== bL) {
                            const x = c * cw; const steps = 8, y0 = r * ch, y1 = (r + 1) * ch; ctx.beginPath(); for (let i = 0; i <= steps; i++) { const t = i / steps; const y = jitter(y0 + t * (y1 - y0), 1.4); const xx = jitter(x, 1.2); if (i === 0) ctx.moveTo(xx, y); else ctx.lineTo(xx, y); } ctx.stroke();
                        }
                    }
                }
                for (let c = 0; c < COLS; c++) {
                    for (let r = 1; r < ROWS; r++) {
                        const aT = LAST_LABELS[(r - 1) * COLS + c], bT = LAST_LABELS[r * COLS + c]; if (aT !== bT) {
                            const y = r * ch; const steps = 8, x0 = c * cw, x1 = (c + 1) * cw; ctx.beginPath(); for (let i = 0; i <= steps; i++) { const t = i / steps; const x = jitter(x0 + t * (x1 - x0), 1.4); const yy = jitter(y, 1.2); if (i === 0) ctx.moveTo(x, yy); else ctx.lineTo(x, yy); } ctx.stroke();
                        }
                    }
                }
            }
            // voronoi
            if (chkVoronoi.checked) {
                ctx.setLineDash([8, 8]); ctx.strokeStyle = '#ffd24a'; ctx.lineWidth = 3; ctx.lineCap = 'round';
                function jitter(n, amp) { return n + (Math.random() * 2 - 1) * amp; }
                // recompute voronoi from centroids
                const vor = new Array(ROWS * COLS).fill(0);
                for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
                    let best = 0, bestd = Infinity; for (let j = 0; j < LAST_K; j++) { const dx = (c + 0.5) - LAST_CENTROIDS[j].x, dy = (r + 0.5) - LAST_CENTROIDS[j].y; const d = dx * dx + dy * dy; if (d < bestd) { bestd = d; best = j; } } vor[r * COLS + c] = best;
                }
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 1; c < COLS; c++) {
                        const aV = vor[r * COLS + c - 1], bV = vor[r * COLS + c]; if (aV !== bV) { const x = c * cw; const steps = 8, y0 = r * ch, y1 = (r + 1) * ch; ctx.beginPath(); for (let i = 0; i <= steps; i++) { const t = i / steps; const y = jitter(y0 + t * (y1 - y0), 1.6); const xx = jitter(x, 1.6); if (i === 0) ctx.moveTo(xx, y); else ctx.lineTo(xx, y); } ctx.stroke(); }
                    }
                }
                for (let c = 0; c < COLS; c++) {
                    for (let r = 1; r < ROWS; r++) {
                        const aV2 = vor[(r - 1) * COLS + c], bV2 = vor[r * COLS + c]; if (aV2 !== bV2) { const y = r * ch; const steps = 8, x0 = c * cw, x1 = (c + 1) * cw; ctx.beginPath(); for (let i = 0; i <= steps; i++) { const t = i / steps; const x = jitter(x0 + t * (x1 - x0), 1.6); const yy = jitter(y, 1.6); if (i === 0) ctx.moveTo(x, yy); else ctx.lineTo(x, yy); } ctx.stroke(); }
                    }
                }
                ctx.setLineDash([]);
            }
            // labels
            if (chkLabels.checked) {
                ctx.font = '600 14px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                for (let i = 0; i < LAST_K; i++) {
                    const cx = LAST_CENTROIDS[i].x * cw, cy = LAST_CENTROIDS[i].y * ch; const pct = ((LAST_AREAS[i] / (ROWS * COLS)) * 100).toFixed(1);
                    // halo
                    ctx.lineWidth = 3; ctx.strokeStyle = '#000'; ctx.strokeText(`#${i} ‚Äî ${pct}%`, cx, cy);
                    ctx.fillStyle = '#fff'; ctx.fillText(`#${i} ‚Äî ${pct}%`, cx, cy);
                }
            }
            // CORS warning if needed
            if (includeImage && !drewImage) {
                ctx.fillStyle = 'rgba(20,20,20,.85)'; ctx.fillRect(8, 8, 320, 54);
                ctx.fillStyle = '#ffd24a'; ctx.font = '700 13px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono"';
                ctx.fillText('BASE IMAGE OMITTED DUE TO CORS', 22, 28);
                ctx.fillStyle = '#e0e0e0'; ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono"';
                ctx.fillText('Host the image with CORS or use a local file/\ndata URL to include it in the export.', 22, 44);
            }

            const url = canvas.toDataURL('image/png');
            const link = document.createElement('a'); link.href = url; link.download = includeImage ? 'grid_annotated.png' : 'grid_overlay.png'; link.click();
        }

        /********************
         * EVENTS
         ********************/
        rebuildBtn.addEventListener('click', () => { setImage(urlInput.value.trim()); assemble(); });
        annotateBtn.addEventListener('click', () => { if (!segSvg.innerHTML.trim() && LAST_LABELS) { renderSegOverlay(LAST_LABELS, LAST_K); } segSvg.classList.toggle('show'); });
        window.addEventListener('resize', () => { if (LAST_LABELS && segSvg.classList.contains('show')) renderSegOverlay(LAST_LABELS, LAST_K); });
        STAGE.addEventListener('click', (e) => {
            const rect = STAGE.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            ORIGIN = { c: Math.max(0, Math.min(COLS - 1, Math.floor(x / (rect.width / COLS)))), r: Math.max(0, Math.min(ROWS - 1, Math.floor(y / (rect.height / ROWS)))) };
            assemble();
        });
        alphaInput.addEventListener('input', () => { segSvg.style.setProperty('--overlay-alpha', Math.max(0, Math.min(1, parseInt(alphaInput.value) / 100))); });
        chkLabels.addEventListener('change', () => { if (LAST_LABELS) renderSegOverlay(LAST_LABELS, LAST_K); });
        chkBounds.addEventListener('change', () => { if (LAST_LABELS) renderSegOverlay(LAST_LABELS, LAST_K); });
        chkVoronoi.addEventListener('change', () => { if (LAST_LABELS) renderSegOverlay(LAST_LABELS, LAST_K); });
        exportAnnBtn.addEventListener('click', () => exportPNG(true));
        exportOverlayBtn.addEventListener('click', () => exportPNG(false));

        /********************
         * SELF‚ÄëTESTS
         ********************/
        function test(name, fn) {
            try { const ok = fn(); const li = document.createElement('li'); li.innerHTML = (ok ? '<span class="pass">PASS</span>' : '<span class="fail">FAIL</span>') + ` ‚Äî ${name}`; TEST_LIST.appendChild(li); if (!ok) console.warn('Test failed:', name); }
            catch (err) { const li = document.createElement('li'); li.innerHTML = `<span class="fail">ERROR</span> ‚Äî ${name}: ${err.message}`; TEST_LIST.appendChild(li); console.error(err); }
        }

        // K-means sanity
        (function () {
            const pts = [[0, 0, 0, 0], [1, 1, 1, 1], [0.1, 0.1, 0.1, 0.2], [0.9, 0.9, 0.9, 0.8]]; const k = 2; const labels = kmeans(pts, k, 4);
            test('kmeans returns n labels & range 0..k-1', () => labels.length === pts.length && labels.every(v => v === 0 || v === 1));
        })();

        // Schedule edges mode monotonicity on sample
        (function () {
            const edges = [0.1, 0.9, 0.3, 0.7]; const order = buildSchedule('edges', edges, null);
            const e = order.map(([id]) => edges[id]);
            test('edges schedule sorts by descending edge strength', () => e.join(',') === e.slice().sort((a, b) => b - a).join(','));
        })();

        // Overlay render sanity (synthetic labels)
        (function () {
            const labels = new Array(ROWS * COLS).fill(0).map((_, i) => (i % COLS < COLS / 2 ? 0 : 1));
            const { cent, areas } = computeCentroidsAndAreas(labels, 2);
            renderSegOverlay(labels, 2);
            test('renderSegOverlay populates SVG', () => segSvg.innerHTML.trim().length > 0);
            test('centroids length equals k', () => cent.length === 2);
            test('areas sum to grid size', () => areas.reduce((a, b) => a + b, 0) === ROWS * COLS);
            segSvg.classList.remove('show'); segSvg.innerHTML = '';
        })();

        // Export smoke test (overlay-only)
        (function () {
            LAST_LABELS = new Array(ROWS * COLS).fill(0).map((_, i) => i % 3);
            LAST_K = 3; const tmp = computeCentroidsAndAreas(LAST_LABELS, LAST_K); LAST_CENTROIDS = tmp.cent; LAST_AREAS = tmp.areas;
            const W = 300, H = 300; const c = document.createElement('canvas'); c.width = W; c.height = H; const ok = !!c.toDataURL('image/png');
            test('canvas toDataURL PNG works', () => ok);
        })();

        /********************
         * BOOT
         ********************/
        makeGrid();
        assemble();
    </script>
</body>

</html>