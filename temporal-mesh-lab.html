<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temporal Mesh Instrumentation Lab</title>
    <style>
        :root {
            --bg-dark: #050508;
            --bg-panel: #0f0f16;
            --text-main: #e2e8f0;
            --accent: #06b6d4;
            --accent-warn: #f59e0b;
            --accent-success: #10b981;
            --border: #1e293b;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg-dark);
            color: var(--text-main);
            font-family: 'JetBrains Mono', monospace;
            overflow: hidden;
            display: flex;
            height: 100vh;
        }

        #sidebar {
            width: 350px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        #main-view {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #000;
        }

        #waterfall-container {
            height: 200px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .panel-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            font-weight: bold;
            color: var(--accent);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .control-group {
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn {
            display: block;
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
            background: rgba(6, 182, 212, 0.1);
            border: 1px solid var(--accent);
            color: var(--accent);
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(6, 182, 212, 0.2);
        }

        .btn.active {
            background: var(--accent);
            color: #000;
        }

        .log-entry {
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            gap: 8px;
        }

        .log-time {
            color: var(--accent-warn);
            min-width: 50px;
        }

        .log-msg {
            color: #ccc;
        }

        .log-detail {
            color: #666;
        }

        #stats-overlay {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px;
            border-radius: 4px;
            border: 1px solid var(--border);
            pointer-events: none;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            gap: 16px;
            font-size: 12px;
            margin-bottom: 4px;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>

    <div id="sidebar">
        <div class="panel-header">
            <span>‚è±Ô∏è Temporal Lab</span>
            <span id="status-badge"
                style="font-size:10px; background:#333; padding:2px 6px; border-radius:4px;">IDLE</span>
        </div>

        <div class="panel-content">
            <div class="control-group">
                <div style="font-size:11px; color:#888; margin-bottom:8px;">INSTRUMENTATION</div>
                <button class="btn" id="btn-patch" onclick="toggleInstrumentation()">üîå Patch THREE.Mesh</button>
                <div id="patch-status" style="font-size:10px; color:#666; margin-top:4px;">Status: Native</div>
            </div>

            <div class="control-group">
                <div style="font-size:11px; color:#888; margin-bottom:8px;">SIMULATION</div>
                <button class="btn" onclick="runRedBullSim()">üêÇ Run Red Bull Sequence</button>
                <button class="btn" onclick="runFullCompileSim()">üèóÔ∏è Run Full Compile</button>
                <input type="file" id="gold-input" accept=".json" style="display:none" onchange="loadGold(this)">
                <button class="btn" onclick="document.getElementById('gold-input').click()">üìÅ Load GOLD File</button>
            </div>

            <div class="control-group">
                <div style="font-size:11px; color:#888; margin-bottom:8px;">PLAYBACK</div>
                <div style="display:flex; gap:4px;">
                    <button class="btn" onclick="visualizer.replay(0.5)">0.5x</button>
                    <button class="btn" onclick="visualizer.replay(1.0)">1x</button>
                    <button class="btn" onclick="visualizer.replay(5.0)">5x</button>
                </div>
                <button class="btn" onclick="resetScene()">üîÑ Reset Scene</button>
            </div>

            <div class="control-group">
                <div style="font-size:11px; color:#888; margin-bottom:8px;">EVENT LOG</div>
                <div id="event-log" style="height: 200px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 4px;">
                </div>
            </div>
        </div>
    </div>

    <div id="main-view">
        <div id="canvas-container">
            <div id="stats-overlay">
                <div class="stat-row"><span>Meshes:</span> <span id="stat-meshes" style="color:var(--accent)">0</span>
                </div>
                <div class="stat-row"><span>Vertices:</span> <span id="stat-verts"
                        style="color:var(--accent-success)">0</span></div>
                <div class="stat-row"><span>Last Birth:</span> <span id="stat-last"
                        style="color:var(--accent-warn)">-</span></div>
                <div class="stat-row"><span>Rate:</span> <span id="stat-rate">0/s</span></div>
            </div>
        </div>
        <div id="waterfall-container">
            <canvas id="waterfall-canvas"></canvas>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // === CORE INSTRUMENTATION ===

        const MESH_TIMELINE = {
            active: false,
            startTime: 0,
            currentBatch: null,
            log: [],
            listeners: []
        };

        // Store original constructors
        const OriginalMesh = THREE.Mesh;
        const OriginalBufferGeometry = THREE.BufferGeometry;

        function toggleInstrumentation() {
            if (MESH_TIMELINE.active) {
                // Restore
                THREE.Mesh = OriginalMesh;
                THREE.BufferGeometry = OriginalBufferGeometry;
                MESH_TIMELINE.active = false;
                document.getElementById('btn-patch').classList.remove('active');
                document.getElementById('patch-status').textContent = 'Status: Native';
                logEvent('SYSTEM', 'Instrumentation disabled');
            } else {
                // Patch
                applyPatches();
                MESH_TIMELINE.active = true;
                document.getElementById('btn-patch').classList.add('active');
                document.getElementById('patch-status').textContent = 'Status: Patched (Monitoring)';
                logEvent('SYSTEM', 'Instrumentation enabled');
            }
        }

        function applyPatches() {
            // Patch Geometry
            THREE.BufferGeometry = function () {
                const geom = new OriginalBufferGeometry();
                geom.userData = { _createdAt: performance.now() };
                return geom;
            };
            THREE.BufferGeometry.prototype = OriginalBufferGeometry.prototype;

            // Patch Mesh
            THREE.Mesh = function (geometry, material) {
                const mesh = new OriginalMesh(geometry, material);
                const now = performance.now();

                // 1. Tag with timestamp
                mesh.userData._createdAt = now;

                // 2. Tag with batch context if active
                if (MESH_TIMELINE.currentBatch) {
                    mesh.userData._batchId = MESH_TIMELINE.currentBatch.id;
                    mesh.userData.lineNum = MESH_TIMELINE.currentBatch.lineNum;
                    mesh.userData._context = MESH_TIMELINE.currentBatch.context;
                }

                // 3. Log event
                const entry = {
                    type: 'mesh-birth',
                    timestamp: now,
                    mesh: mesh,
                    lineNum: mesh.userData.lineNum,
                    vertexCount: geometry?.attributes?.position?.count || 0
                };

                MESH_TIMELINE.log.push(entry);
                notifyListeners(entry);

                return mesh;
            };
            THREE.Mesh.prototype = OriginalMesh.prototype;
        }

        function notifyListeners(event) {
            MESH_TIMELINE.listeners.forEach(cb => cb(event));
        }

        // === VISUALIZER ===

        class MeshBirthVisualizer {
            constructor(scene) {
                this.scene = scene;
                this.births = [];

                // Listen for births
                MESH_TIMELINE.listeners.push(this.onBirth.bind(this));
            }

            onBirth(event) {
                this.births.push(event);

                // Update stats
                document.getElementById('stat-meshes').textContent = this.births.length;
                document.getElementById('stat-last').textContent = event.timestamp.toFixed(1) + 'ms';

                logEvent('MESH', `Born: Line ${event.lineNum || '?'} (${event.vertexCount}v)`);

                // Animate in scene
                if (event.mesh.parent === null) {
                    // If mesh isn't added to scene yet, we can't animate it easily here
                    // But usually it gets added shortly after.
                    // For this lab, we'll auto-add it if it's orphan, just for viz
                    this.scene.add(event.mesh);
                }

                this.animateBirth(event.mesh);
                this.updateWaterfall();
            }

            animateBirth(mesh) {
                const startScale = mesh.scale.clone();
                mesh.scale.set(0.01, 0.01, 0.01);

                // Simple tween
                let progress = 0;
                const animate = () => {
                    progress += 0.05;
                    if (progress > 1) progress = 1;

                    // Elastic ease out
                    const p = progress;
                    const ease = p === 0 ? 0 : p === 1 ? 1 : Math.pow(2, -10 * p) * Math.sin((p * 10 - 0.75) * (2 * Math.PI) / 3) + 1;

                    mesh.scale.lerpVectors(new THREE.Vector3(0.01, 0.01, 0.01), startScale, ease);

                    if (progress < 1) requestAnimationFrame(animate);
                };
                animate();

                // Flash material
                if (mesh.material) {
                    const oldColor = mesh.material.color.getHex();
                    mesh.material.color.setHex(0xffffff);
                    setTimeout(() => {
                        if (mesh.material) mesh.material.color.setHex(oldColor);
                    }, 100);
                }
            }

            updateWaterfall() {
                const canvas = document.getElementById('waterfall-canvas');
                const ctx = canvas.getContext('2d');
                const w = canvas.width = canvas.parentElement.clientWidth;
                const h = canvas.height = canvas.parentElement.clientHeight;

                ctx.fillStyle = '#0f0f16';
                ctx.fillRect(0, 0, w, h);

                if (this.births.length === 0) return;

                const startTime = this.births[0].timestamp;
                const endTime = performance.now();
                const totalTime = Math.max(1000, endTime - startTime);

                this.births.forEach((b, i) => {
                    const x = ((b.timestamp - startTime) / totalTime) * w;
                    const y = (i / this.births.length) * h;
                    const height = Math.max(2, h / this.births.length);

                    const hue = ((b.lineNum || 0) * 137.5) % 360;
                    ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                    ctx.fillRect(x, y, 4, height);

                    // Trail
                    ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.2)`;
                    ctx.fillRect(0, y, x, height);
                });

                // Current time line
                ctx.strokeStyle = '#f59e0b';
                ctx.beginPath();
                ctx.moveTo(w - 1, 0);
                ctx.lineTo(w - 1, h);
                ctx.stroke();
            }

            replay(speed = 1.0) {
                if (this.births.length === 0) return;

                logEvent('REPLAY', `Starting replay at ${speed}x`);
                resetScene(false); // Keep logs, clear scene

                const t0 = this.births[0].timestamp;

                this.births.forEach(b => {
                    const delay = (b.timestamp - t0) / speed;
                    setTimeout(() => {
                        this.scene.add(b.mesh);
                        this.animateBirth(b.mesh);
                        logEvent('REPLAY', `Line ${b.lineNum}`);
                    }, delay);
                });
            }
        }

        // === SCENE SETUP ===

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        function init() {
            const container = document.getElementById('canvas-container');
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            camera.position.set(100, 100, 100);
            camera.lookAt(0, 0, 0);

            // Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);
            const dir = new THREE.DirectionalLight(0xffffff, 1);
            dir.position.set(50, 100, 50);
            scene.add(dir);

            // Grid
            scene.add(new THREE.GridHelper(200, 20, 0x333333, 0x111111));

            animate();

            // Auto-enable instrumentation
            toggleInstrumentation();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        const visualizer = new MeshBirthVisualizer(scene);

        // === SIMULATION LOGIC ===

        async function runRedBullSim() {
            resetScene();
            logEvent('SIM', 'Starting Red Bull Sequence...');

            const lines = [22, 30, 38, 46, 54, 62, 70, 78];

            for (const lineNum of lines) {
                // 1. Start Batch
                const batchId = `batch_${Date.now()}_${lineNum}`;
                MESH_TIMELINE.currentBatch = {
                    id: batchId,
                    lineNum: lineNum,
                    context: 'RedBull'
                };

                logEvent('BATCH', `Started Line ${lineNum}`);

                // 2. Simulate Load (Random delay + Mesh creation)
                await delay(50 + Math.random() * 100);

                // Create "Part" (Group of meshes)
                const color = Math.random() * 0xffffff;
                const geometry = new THREE.BoxGeometry(10, 4, 10);
                const material = new THREE.MeshStandardMaterial({ color: color });

                // Position based on line number (spiral)
                const angle = lineNum * 0.5;
                const radius = 30 + lineNum * 0.5;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, 0, z);

                // 3. End Batch
                MESH_TIMELINE.currentBatch = null;

                await delay(100);
            }

            logEvent('SIM', 'Sequence Complete');
        }

        async function runFullCompileSim() {
            resetScene();
            logEvent('SIM', 'Starting Full Compile...');

            // Single batch for whole file
            MESH_TIMELINE.currentBatch = {
                id: 'full_compile',
                lineNum: -1, // Unknown in full compile usually
                context: 'FullLoad'
            };

            for (let i = 0; i < 50; i++) {
                const geometry = new THREE.SphereGeometry(2, 8, 8);
                const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
                const mesh = new THREE.Mesh(geometry, material);

                mesh.position.set(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 50 + 25,
                    (Math.random() - 0.5) * 100
                );

                // In full compile, lineNum isn't set automatically by batch
                // But our patch will capture the timestamp!

                await delay(10); // Fast burst
            }

            MESH_TIMELINE.currentBatch = null;
            logEvent('SIM', 'Compile Complete');
        }

        // === GOLD LOADER INTEGRATION ===

        function loadGold(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const gold = JSON.parse(e.target.result);
                    await simulateGoldReplay(gold);
                } catch (err) {
                    logEvent('ERROR', err.message);
                }
            };
            reader.readAsText(file);
        }

        async function simulateGoldReplay(gold) {
            resetScene();
            logEvent('GOLD', `Loaded ${gold.mpd_content.length} bytes`);

            const lines = gold.mpd_content.split('\n');
            const partLines = [];
            lines.forEach((line, idx) => {
                if (line.trim().startsWith('1 ')) {
                    partLines.push({ idx, text: line });
                }
            });

            logEvent('GOLD', `Found ${partLines.length} parts to build`);

            // Simulate building them
            for (const part of partLines) {
                // Set context
                MESH_TIMELINE.currentBatch = {
                    id: `gold_${part.idx}`,
                    lineNum: part.idx,
                    context: 'GoldReplay'
                };

                // Parse coords roughly
                const tokens = part.text.trim().split(/\s+/);
                const x = parseFloat(tokens[2]);
                const y = parseFloat(tokens[3]);
                const z = parseFloat(tokens[4]);
                const color = parseInt(tokens[1]);

                // Create proxy mesh
                const geom = new THREE.BoxGeometry(4, 4, 4);
                const mat = new THREE.MeshStandardMaterial({
                    color: getColor(color),
                    roughness: 0.4
                });
                const mesh = new THREE.Mesh(geom, mat);
                mesh.position.set(x, -y, z); // LDraw Y flip

                MESH_TIMELINE.currentBatch = null;

                await delay(20); // Fast replay
            }
        }

        // === UTILS ===

        function logEvent(type, msg) {
            const div = document.createElement('div');
            div.className = 'log-entry';
            div.innerHTML = `
            <span class="log-time">${performance.now().toFixed(0)}</span>
            <span class="log-msg">[${type}]</span>
            <span class="log-detail">${msg}</span>
        `;
            const container = document.getElementById('event-log');
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function resetScene(clearLogs = true) {
            // Remove meshes
            for (let i = scene.children.length - 1; i >= 0; i--) {
                const child = scene.children[i];
                if (child.isMesh || child.isGroup) {
                    scene.remove(child);
                }
            }
            // Keep lights/grid

            if (clearLogs) {
                document.getElementById('event-log').innerHTML = '';
                visualizer.births = [];
                document.getElementById('stat-meshes').textContent = '0';
            }
        }

        function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

        function getColor(code) {
            const map = { 0: 0x111111, 1: 0x0055bf, 4: 0xc91a09, 15: 0xffffff, 72: 0xe6e6e6 };
            return map[code] || 0x888888;
        }

        // Start
        init();

        // Handle resize
        window.addEventListener('resize', () => {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

    </script>
</body>

</html>